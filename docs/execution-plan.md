# LUMOS Execution Plan

**Status:** In Progress - Phase 1
**Last Updated:** 2025-01-17
**Current Focus:** Code Generators Implementation

---

## Table of Contents

1. [Phase 1: Core Parser & Generators](#phase-1-core-parser--generators) ‚è≥
2. [Phase 2: CLI & Developer Tools](#phase-2-cli--developer-tools)
3. [Phase 3: Advanced Features & Ecosystem](#phase-3-advanced-features--ecosystem)
4. [Testing Strategy](#testing-strategy)
5. [Success Metrics](#success-metrics)

---

## Phase 1: Core Parser & Generators

**Goal:** Build fully functional .lumos parser and code generators for Rust and TypeScript

### 1.1 Parser Implementation ‚úÖ COMPLETED

**Status:** ‚úÖ Done (21/21 tests passing)

#### Deliverables Completed:
- [x] AST structure (`ast.rs`)
- [x] Parser using syn (`parser.rs`)
- [x] AST to IR transformer (`transform.rs`)
- [x] Integration tests with 5 real-world schemas
- [x] Updated syntax reference to Rust-style `#[attribute]`
- [x] All example schemas converted and validated

#### Technical Decisions Made:
- Using `syn` crate for parsing (battle-tested Rust parser)
- Rust-style `#[attribute]` syntax for familiarity with target audience
- Type mapping supports both Rust types and TypeScript-friendly aliases
- Pipeline: `.lumos` ‚Üí Parser ‚Üí AST ‚Üí Transformer ‚Üí IR

**Commit:** `37e3442` (pushed to `dev`)

---

### 1.2 Rust Code Generator üéØ NEXT

**Priority:** High
**Estimated Effort:** 3-5 hours
**Status:** Not Started

#### Objective
Generate production-ready Rust code from IR that integrates seamlessly with Anchor programs.

#### Scope

**Input:** IR (Intermediate Representation) from `transform.rs`
**Output:** Rust source code (`.rs` files)

#### Detailed Tasks

1. **Create `generators/rust.rs` module** (expand existing stub)
   - [ ] Design generator architecture
   - [ ] Implement `RustGenerator` struct
   - [ ] Add configuration options (derive macros, visibility, etc.)

2. **Implement struct generation**
   - [ ] Generate struct definitions with proper formatting
   - [ ] Add `#[derive(...)]` macros based on metadata
   - [ ] Handle field visibility (`pub` by default for Solana)
   - [ ] Generate proper documentation comments

3. **Type mapping**
   - [ ] Map IR types to Rust types
   - [ ] Handle `Option<T>` types
   - [ ] Handle `Vec<T>` for arrays
   - [ ] Handle Solana-specific types (`Pubkey`, `Signature`)

4. **Solana/Anchor integration**
   - [ ] Add `#[account]` attribute for Anchor accounts
   - [ ] Add Borsh derive macros (`BorshSerialize`, `BorshDeserialize`)
   - [ ] Generate proper imports (`use solana_program::pubkey::Pubkey`)
   - [ ] Handle account discriminator if needed

5. **Formatting & quality**
   - [ ] Run generated code through `rustfmt`
   - [ ] Ensure no clippy warnings
   - [ ] Add file header comments (license, auto-generated notice)

6. **Testing**
   - [ ] Unit tests for type mapping
   - [ ] Unit tests for struct generation
   - [ ] Integration test: parse example schema ‚Üí generate Rust ‚Üí compile successfully
   - [ ] Verify generated code matches hand-written equivalent

#### Example Output

**Input IR:**
```rust
TypeDefinition {
    name: "UserAccount",
    metadata: Metadata { solana: true, attributes: ["account"] },
    fields: [
        FieldDefinition {
            name: "wallet",
            type_info: TypeInfo::Primitive("Pubkey"),
            optional: false
        },
        FieldDefinition {
            name: "balance",
            type_info: TypeInfo::Primitive("u64"),
            optional: false
        }
    ]
}
```

**Generated Rust:**
```rust
// Auto-generated by LUMOS
// DO NOT EDIT - Changes will be overwritten

use borsh::{BorshSerialize, BorshDeserialize};
use solana_program::pubkey::Pubkey;

#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]
#[account]
pub struct UserAccount {
    pub wallet: Pubkey,
    pub balance: u64,
}
```

#### Acceptance Criteria

- [ ] Generated Rust code compiles without errors
- [ ] Generated code passes clippy with no warnings
- [ ] All 5 example schemas generate valid Rust code
- [ ] Generated code is idiomatic and production-ready
- [ ] Test coverage: 80%+ for generator logic

#### Dependencies

- ‚úÖ IR structure defined in `ir.rs`
- ‚úÖ Parser pipeline functional
- ‚è≥ `quote` crate for code generation (already in dependencies)

#### Files to Create/Modify

- `packages/core/src/generators/rust.rs` (expand existing)
- `packages/core/tests/test_rust_generator.rs` (new)
- `examples/*/generated/rust/` (generated output for verification)

---

### 1.3 TypeScript Code Generator

**Priority:** High
**Estimated Effort:** 3-5 hours
**Status:** Not Started

#### Objective
Generate TypeScript interfaces and helper code from IR for seamless client-side integration.

#### Scope

**Input:** IR (Intermediate Representation)
**Output:** TypeScript source code (`.ts` files)

#### Detailed Tasks

1. **Create TypeScript generator** (expand `generators/typescript.rs`)
   - [ ] Implement `TypeScriptGenerator` struct
   - [ ] Add configuration (interface vs type, export style, etc.)

2. **Interface generation**
   - [ ] Generate TypeScript interfaces
   - [ ] Handle optional fields (`field?: type`)
   - [ ] Generate proper JSDoc comments
   - [ ] Support both ESM and CommonJS output

3. **Type mapping**
   - [ ] Map IR types to TypeScript types
   - [ ] Handle Rust-specific types (`u64` ‚Üí `number` or `bigint`)
   - [ ] Handle Solana types (`Pubkey` ‚Üí `PublicKey` from `@solana/web3.js`)
   - [ ] Handle arrays and optional types

4. **Solana/Web3.js integration**
   - [ ] Generate proper imports (`import { PublicKey } from '@solana/web3.js'`)
   - [ ] Generate Borsh schema for serialization
   - [ ] Add helper methods for account parsing
   - [ ] Generate TypeScript enums for Rust enums (future)

5. **Code quality**
   - [ ] Format with Prettier (or equivalent)
   - [ ] Ensure ESLint-compatible code
   - [ ] Add file header (license, auto-generated notice)

6. **Testing**
   - [ ] Unit tests for type mapping
   - [ ] Unit tests for interface generation
   - [ ] Integration test: parse schema ‚Üí generate TS ‚Üí TypeScript compiler validates
   - [ ] Verify generated code matches hand-written equivalent

#### Example Output

**Input IR:** (same as Rust example)

**Generated TypeScript:**
```typescript
// Auto-generated by LUMOS
// DO NOT EDIT - Changes will be overwritten

import { PublicKey } from '@solana/web3.js';
import * as borsh from '@coral-xyz/borsh';

export interface UserAccount {
  wallet: PublicKey;
  balance: number;
}

export const UserAccountSchema = borsh.struct([
  borsh.publicKey('wallet'),
  borsh.u64('balance'),
]);
```

#### Acceptance Criteria

- [ ] Generated TypeScript compiles without errors (via `tsc`)
- [ ] All 5 example schemas generate valid TypeScript
- [ ] Generated code is idiomatic TypeScript
- [ ] Borsh schemas match Rust definitions exactly
- [ ] Test coverage: 80%+ for generator logic

#### Dependencies

- ‚úÖ IR structure
- ‚è≥ TypeScript for testing generated code

#### Files to Create/Modify

- `packages/core/src/generators/typescript.rs` (expand existing)
- `packages/core/tests/test_typescript_generator.rs` (new)
- `examples/*/generated/typescript/` (generated output)

---

### 1.4 End-to-End Integration Testing

**Priority:** Medium
**Estimated Effort:** 2-3 hours
**Status:** Not Started

#### Objective
Ensure the complete pipeline works: `.lumos` ‚Üí Rust + TypeScript with perfect type safety.

#### Tasks

1. **Create E2E test suite**
   - [ ] Test: Parse ‚Üí Generate Rust ‚Üí Compile with `rustc`
   - [ ] Test: Parse ‚Üí Generate TypeScript ‚Üí Compile with `tsc`
   - [ ] Test: Verify Rust and TS types are compatible (same serialization)
   - [ ] Test: All 5 example schemas pass E2E

2. **Serialization compatibility**
   - [ ] Create test data in Rust, deserialize in TypeScript
   - [ ] Create test data in TypeScript, deserialize in Rust
   - [ ] Verify Borsh serialization matches byte-for-byte

3. **Documentation**
   - [ ] Update README with code generation examples
   - [ ] Create "How It Works" diagram showing pipeline
   - [ ] Add troubleshooting guide

#### Acceptance Criteria

- [ ] Can generate Rust + TypeScript from all example schemas
- [ ] Generated code compiles in both languages
- [ ] Serialization is compatible bidirectionally
- [ ] Documentation clearly explains the workflow

---

## Phase 2: CLI & Developer Tools

**Status:** üîú Planned
**Start Date:** After Phase 1 completion

### 2.1 CLI Implementation

#### Objectives
- Make LUMOS usable via command line
- Support project initialization, code generation, and validation

#### Commands to Implement

1. **`lumos init [project-name]`**
   - Creates new LUMOS project with example schema
   - Generates config file (`.lumosrc` or `lumos.toml`)
   - Sets up recommended directory structure

2. **`lumos generate [schema.lumos]`**
   - Parse .lumos file
   - Generate Rust code to `src/generated/`
   - Generate TypeScript code to `src/generated/`
   - Watch mode: `lumos generate --watch`

3. **`lumos validate [schema.lumos]`**
   - Parse and validate schema
   - Check for errors and warnings
   - Report issues with helpful messages

4. **`lumos check`**
   - Verify generated code is up-to-date
   - Lint schema files
   - Check for breaking changes

#### Tasks

- [ ] Wire parser to CLI commands
- [ ] Implement file I/O for reading schemas
- [ ] Implement file output for generated code
- [ ] Add progress indicators and colored output
- [ ] Add configuration file support
- [ ] Write CLI tests

#### Files to Create/Modify

- `packages/cli/src/commands/init.rs`
- `packages/cli/src/commands/generate.rs`
- `packages/cli/src/commands/validate.rs`
- `packages/cli/src/config.rs`

---

### 2.2 VSCode Extension

#### Objectives
- Syntax highlighting for `.lumos` files
- IntelliSense and autocomplete
- Real-time validation
- Code snippets

#### Tasks

1. **Basic extension setup**
   - [ ] Create extension scaffold
   - [ ] Define `.lumos` language in `package.json`
   - [ ] Create TextMate grammar for syntax highlighting

2. **Syntax highlighting**
   - [ ] Highlight keywords: `struct`, `enum`, etc.
   - [ ] Highlight types: `u64`, `String`, `PublicKey`
   - [ ] Highlight attributes: `#[solana]`, `#[account]`
   - [ ] Highlight comments

3. **Language server (optional but recommended)**
   - [ ] Implement LSP server in Rust
   - [ ] Provide diagnostics (errors/warnings)
   - [ ] Provide hover information
   - [ ] Provide go-to-definition

4. **Code snippets**
   - [ ] Snippet: Basic struct
   - [ ] Snippet: Solana account
   - [ ] Snippet: Common patterns

#### Files to Create

- `packages/vscode-extension/package.json`
- `packages/vscode-extension/syntaxes/lumos.tmLanguage.json`
- `packages/vscode-extension/snippets/lumos.json`

---

## Phase 3: Advanced Features & Ecosystem

**Status:** üìã Future Planning

### 3.1 Advanced Code Generation

- [ ] Generate Anchor instruction handlers
- [ ] Generate client SDK methods
- [ ] Generate test helpers
- [ ] Support for enums and complex types

### 3.2 Validation & Constraints

- [ ] `#[min(n)]`, `#[max(n)]` constraints
- [ ] `#[range(min, max)]`
- [ ] Custom validation rules

### 3.3 PDA (Program Derived Address) Support

- [ ] `#[pda(seeds = [...])]` macro
- [ ] Generate PDA derivation functions
- [ ] Generate TypeScript PDA helpers

### 3.4 Documentation Generation

- [ ] Generate API documentation from schemas
- [ ] Create schema documentation website
- [ ] Generate integration guides

### 3.5 Ecosystem Integration

- [ ] Solana Foundation grant application
- [ ] Community feedback and iteration
- [ ] Integration with popular Solana tools
- [ ] Plugin system for custom generators

---

## Testing Strategy

### Unit Tests
- **Target:** 80%+ code coverage
- **Focus:** Individual functions and modules
- **Tools:** Rust's built-in test framework

### Integration Tests
- **Target:** All example schemas
- **Focus:** Parser ‚Üí IR ‚Üí Generators pipeline
- **Location:** `packages/core/tests/`

### End-to-End Tests
- **Target:** Complete workflows
- **Focus:** `.lumos` ‚Üí compiled Rust/TypeScript
- **Validation:** Generated code compiles and runs

### Continuous Integration
- [ ] Set up GitHub Actions
- [ ] Run tests on every PR
- [ ] Check formatting (rustfmt)
- [ ] Check linting (clippy)
- [ ] Test on multiple platforms (Linux, macOS, Windows)

---

## Success Metrics

### Phase 1 Success Criteria

- [ ] Parse all example schemas without errors
- [ ] Generate compilable Rust code
- [ ] Generate compilable TypeScript code
- [ ] Borsh serialization compatible between Rust and TS
- [ ] 21+ tests passing
- [ ] Documentation complete and accurate

### Phase 2 Success Criteria

- [ ] CLI commands functional
- [ ] VSCode extension published
- [ ] Developer experience is smooth
- [ ] Community adoption begins

### Phase 3 Success Criteria

- [ ] Advanced features implemented
- [ ] Solana ecosystem integration
- [ ] Active community contributions
- [ ] Production usage in real projects

---

## Timeline Estimate

### Phase 1 (Current Focus)
- **Parser:** ‚úÖ 3 days (completed)
- **Rust Generator:** üéØ 2-3 days
- **TypeScript Generator:** 2-3 days
- **Integration Testing:** 1-2 days
- **Total:** ~2 weeks

### Phase 2
- **CLI:** 3-5 days
- **VSCode Extension:** 5-7 days
- **Total:** ~2-3 weeks

### Phase 3
- **Iterative development:** Ongoing based on feedback

---

## Decision Log

### 2025-01-17: Attribute Syntax Decision
**Decision:** Use Rust-style `#[attribute]` instead of `@attribute`
**Rationale:**
- Consistent with syn parser
- Familiar to Rust/Anchor developers (target audience)
- Enables better IDE support via existing Rust tooling

**Impact:** Updated all documentation and example schemas

### 2025-01-17: Parser Choice
**Decision:** Use `syn` crate instead of custom lexer/parser
**Rationale:**
- Battle-tested and maintained
- Handles Rust syntax perfectly
- Reduces maintenance burden
- Excellent error messages

**Impact:** Faster development, higher quality

---

## Next Session Tasks

**Immediate Focus:** Rust Code Generator (Section 1.2)

1. Expand `packages/core/src/generators/rust.rs`
2. Implement struct generation from IR
3. Add Solana/Anchor-specific derives and attributes
4. Create comprehensive tests
5. Verify all example schemas generate valid Rust

**After Rust Generator:** Move to TypeScript Generator (Section 1.3)

---

## Notes

- Keep generators simple and focused initially
- Prioritize correctness over features
- Ensure generated code is production-ready
- Document all design decisions
- Test with real-world Solana programs

---

**Updated by:** CIPHER
**Next Review:** After Rust Generator completion
