// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Anchor Framework commands - IDL, space calculation, and program generation

use anyhow::Result;
use colored::Colorize;
use lumos_core::anchor::{
    generate_accounts_context, parse_anchor_attrs, IdlGenerator, IdlGeneratorConfig,
    InstructionAccount, InstructionContext,
};
use lumos_core::generators::typescript;
use lumos_core::ir::TypeDefinition;
use std::fs;
use std::path::{Path, PathBuf};

use crate::commands::generate::resolve_schema;
use crate::utils::{infer_anchor_account_type, type_info_to_rust_type, validate_output_path};
use bs58;

/// Generate Anchor IDL from LUMOS schema
pub fn run_idl(
    schema_path: &Path,
    output_path: Option<&Path>,
    program_name: Option<&str>,
    version: &str,
    address: Option<&str>,
    pretty: bool,
) -> Result<()> {
    // Parse and transform schema
    let (type_defs, _file_count) = resolve_schema(schema_path)?;

    // Derive program name from schema filename if not provided
    let name = program_name.map(String::from).unwrap_or_else(|| {
        schema_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("my_program")
            .to_string()
    });

    // Configure IDL generator
    let config = IdlGeneratorConfig {
        program_name: name.clone(),
        version: version.to_string(),
        address: address.map(String::from),
    };

    // Generate IDL
    let generator = IdlGenerator::new(config);
    let idl = generator.generate(&type_defs);

    // Serialize to JSON
    let json_output = if pretty {
        serde_json::to_string_pretty(&idl)?
    } else {
        serde_json::to_string(&idl)?
    };

    // Determine output path
    if let Some(out_path) = output_path {
        // Validate output path
        validate_output_path(out_path)?;
        fs::write(out_path, &json_output)?;
        println!("{:>12} {}", "Generated".green().bold(), out_path.display());
    } else {
        // Default: target/idl/<program_name>.json
        let default_path = PathBuf::from("target/idl").join(format!("{}.json", name));

        // Create directory if it doesn't exist
        if let Some(parent) = default_path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::write(&default_path, &json_output)?;
        println!(
            "{:>12} {}",
            "Generated".green().bold(),
            default_path.display()
        );
    }

    // Print summary
    let account_count = idl.accounts.len();
    let type_count = idl.types.len();

    println!();
    println!("{}", "IDL Summary:".bold());
    println!("  Program: {}", idl.name.cyan());
    println!("  Version: {}", idl.version);
    if let Some(ref meta) = idl.metadata {
        if let Some(ref addr) = meta.address {
            println!("  Address: {}", addr);
        }
    }
    println!("  Accounts: {}", account_count);
    println!("  Types: {}", type_count);

    Ok(())
}

/// Generate Anchor account space constants
pub fn run_space(schema_path: &Path, format: &str, account_name: Option<&str>) -> Result<()> {
    // Parse and transform schema
    let (type_defs, _file_count) = resolve_schema(schema_path)?;

    // Create generator for space calculation
    let generator = IdlGenerator::new(IdlGeneratorConfig::default());

    // Find account types
    let accounts: Vec<_> = type_defs
        .iter()
        .filter_map(|td| {
            if let TypeDefinition::Struct(struct_def) = td {
                if struct_def
                    .metadata
                    .attributes
                    .iter()
                    .any(|a| a == "account")
                {
                    if let Some(name) = account_name {
                        if struct_def.name != name {
                            return None;
                        }
                    }
                    return Some(struct_def);
                }
            }
            None
        })
        .collect();

    if accounts.is_empty() {
        if let Some(name) = account_name {
            println!(
                "{:>12} No account '{}' found in schema",
                "Warning".yellow().bold(),
                name
            );
        } else {
            println!(
                "{:>12} No account types found in schema",
                "Warning".yellow().bold()
            );
            println!("  Hint: Add #[account] attribute to struct definitions");
        }
        return Ok(());
    }

    println!("{:>12} account space...\n", "Calculating".cyan().bold());

    if format == "rust" {
        // Generate Rust code
        println!("// Auto-generated account space constants");
        println!("// Generated by: lumos anchor space\n");

        for account in &accounts {
            let space = generator.calculate_account_space(account);
            println!("impl {} {{", account.name);
            println!("    /// Account size including 8-byte discriminator");
            println!("    pub const LEN: usize = {};", space);
            println!("}}\n");
        }
    } else {
        // Text output
        println!(
            "{:<30} {:>10} {:>15}",
            "Account".bold(),
            "Size".bold(),
            "Breakdown".bold()
        );
        println!("{}", "-".repeat(60));

        for account in &accounts {
            let space = generator.calculate_account_space(account);
            let breakdown = format!("8 (disc) + {} (data)", space - 8);
            println!(
                "{:<30} {:>10} {:>15}",
                account.name,
                format!("{} bytes", space),
                breakdown
            );
        }

        println!();
        println!("{}", "Note:".bold());
        println!("  - Size includes 8-byte Anchor discriminator");
        println!("  - Variable-length fields (String, Vec) show prefix only");
        println!("  - Max Solana account size: 10,485,760 bytes (10 MiB)");
    }

    Ok(())
}

/// Generate complete Anchor program from LUMOS schema
///
/// This command generates:
/// 1. Rust program with #[derive(Accounts)] contexts for instruction structs
/// 2. Account LEN constants for all account types
/// 3. Anchor IDL JSON
/// 4. TypeScript client (optional)
pub fn run_generate(
    schema_path: &Path,
    output_dir: Option<&Path>,
    program_name: Option<&str>,
    version: &str,
    address: &str,
    generate_typescript: bool,
    dry_run: bool,
) -> Result<()> {
    let output_dir = output_dir.unwrap_or_else(|| Path::new("."));

    // Validate output directory
    if !dry_run {
        validate_output_path(output_dir)?;
    }

    // Parse and transform schema
    let (type_defs, _file_count) = resolve_schema(schema_path)?;

    // Derive program name from schema filename if not provided
    let name = program_name.map(String::from).unwrap_or_else(|| {
        schema_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("my_program")
            .to_string()
    });

    println!(
        "{:>12} Anchor program '{}'...\n",
        "Generating".cyan().bold(),
        name
    );

    // Validate provided program address (must be valid base58 Pubkey, 32 bytes)
    match bs58::decode(address).into_vec() {
        Ok(bytes) if bytes.len() == 32 => {}
        _ => {
            anyhow::bail!(
                "Invalid --address: must be a valid base58-encoded 32-byte Solana program ID"
            );
        }
    }

    // Configure IDL generator
    let idl_config = IdlGeneratorConfig {
        program_name: name.clone(),
        version: version.to_string(),
        address: Some(address.to_string()),
    };
    let idl_generator = IdlGenerator::new(idl_config);

    // Collect accounts, instructions, and types
    let mut accounts = Vec::new();
    let mut instructions = Vec::new();
    let mut other_types = Vec::new();

    for type_def in &type_defs {
        match type_def {
            TypeDefinition::Struct(s) => {
                let is_account = s.metadata.attributes.iter().any(|a| a == "account");
                let is_instruction = s.metadata.is_instruction;

                if is_instruction {
                    instructions.push(s);
                } else if is_account {
                    accounts.push(s);
                } else {
                    other_types.push(type_def);
                }
            }
            TypeDefinition::Enum(_) | TypeDefinition::TypeAlias(_) => {
                other_types.push(type_def);
            }
        }
    }

    // === Generate Rust Code ===
    let mut rust_output = String::new();

    // Header comment
    rust_output.push_str("// Auto-generated by LUMOS - Anchor Program\n");
    rust_output.push_str(&format!("// Source: {}\n", schema_path.display()));
    rust_output.push_str(&format!("// Program: {}\n", name));
    rust_output.push_str(&format!("// Version: {}\n\n", version));

    // Imports
    rust_output.push_str("use anchor_lang::prelude::*;\n\n");

    // Program ID declaration
    rust_output.push_str(&format!("declare_id!(\"{}\");\n\n", address));

    // Generate account structs with LEN constants
    if !accounts.is_empty() {
        rust_output.push_str(
            "// ============================================================================\n",
        );
        rust_output.push_str("// Account Types\n");
        rust_output.push_str(
            "// ============================================================================\n\n",
        );

        for account in &accounts {
            // Account struct
            rust_output.push_str("#[account]\n");
            rust_output.push_str(&format!("pub struct {} {{\n", account.name));
            for field in &account.fields {
                let rust_type = type_info_to_rust_type(&field.type_info);
                rust_output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
            }
            rust_output.push_str("}\n\n");

            // LEN constant
            let space = idl_generator.calculate_account_space(account);
            rust_output.push_str(&format!("impl {} {{\n", account.name));
            rust_output.push_str("    /// Account size including 8-byte discriminator\n");
            rust_output.push_str(&format!("    pub const LEN: usize = {};\n", space));
            rust_output.push_str("}\n\n");
        }
    }

    // Generate instruction contexts
    if !instructions.is_empty() {
        rust_output.push_str(
            "// ============================================================================\n",
        );
        rust_output.push_str("// Instruction Contexts\n");
        rust_output.push_str(
            "// ============================================================================\n\n",
        );

        for instruction in &instructions {
            // Build InstructionContext from the struct
            let mut ctx_accounts = Vec::new();

            for field in &instruction.fields {
                let mut attrs = Vec::new();
                for attr_str in &field.anchor_attrs {
                    attrs.extend(parse_anchor_attrs(attr_str));
                }

                let account_type = infer_anchor_account_type(&field.type_info);

                ctx_accounts.push(InstructionAccount {
                    name: field.name.clone(),
                    account_type,
                    attrs,
                    optional: field.optional,
                    docs: vec![],
                });
            }

            let ctx = InstructionContext {
                name: instruction.name.clone(),
                accounts: ctx_accounts,
                args: vec![],
            };

            // Generate the #[derive(Accounts)] context
            rust_output.push_str(&generate_accounts_context(&ctx));
            rust_output.push('\n');
        }
    }

    // Generate other types (enums, non-account structs)
    if !other_types.is_empty() {
        rust_output.push_str(
            "// ============================================================================\n",
        );
        rust_output.push_str("// Custom Types\n");
        rust_output.push_str(
            "// ============================================================================\n\n",
        );

        for type_def in &other_types {
            match type_def {
                TypeDefinition::Struct(s) => {
                    rust_output
                        .push_str("#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]\n");
                    rust_output.push_str(&format!("pub struct {} {{\n", s.name));
                    for field in &s.fields {
                        let rust_type = type_info_to_rust_type(&field.type_info);
                        rust_output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
                    }
                    rust_output.push_str("}\n\n");
                }
                TypeDefinition::Enum(e) => {
                    rust_output.push_str(
                        "#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug, PartialEq)]\n",
                    );
                    rust_output.push_str(&format!("pub enum {} {{\n", e.name));
                    for variant in &e.variants {
                        match variant {
                            lumos_core::ir::EnumVariantDefinition::Unit { name } => {
                                rust_output.push_str(&format!("    {},\n", name));
                            }
                            lumos_core::ir::EnumVariantDefinition::Tuple { name, types } => {
                                let type_strs: Vec<String> =
                                    types.iter().map(type_info_to_rust_type).collect();
                                rust_output.push_str(&format!(
                                    "    {}({}),\n",
                                    name,
                                    type_strs.join(", ")
                                ));
                            }
                            lumos_core::ir::EnumVariantDefinition::Struct { name, fields } => {
                                rust_output.push_str(&format!("    {} {{\n", name));
                                for field in fields {
                                    let rust_type = type_info_to_rust_type(&field.type_info);
                                    rust_output.push_str(&format!(
                                        "        {}: {},\n",
                                        field.name, rust_type
                                    ));
                                }
                                rust_output.push_str("    },\n");
                            }
                        }
                    }
                    rust_output.push_str("}\n\n");
                }
                TypeDefinition::TypeAlias(_) => {
                    // Type aliases are resolved, skip
                }
            }
        }
    }

    // === Generate IDL ===
    let idl = idl_generator.generate(&type_defs);
    let idl_json = serde_json::to_string_pretty(&idl)?;

    // === Generate TypeScript (optional) ===
    let ts_output = if generate_typescript {
        Some(typescript::generate_module(&type_defs))
    } else {
        None
    };

    // === Output Results ===
    if dry_run {
        println!("{}", "=== DRY RUN - No files written ===\n".yellow().bold());

        println!("{}", "Rust Program (lib.rs):".bold());
        println!("{}", "-".repeat(60));
        println!("{}", rust_output);

        println!("{}", "IDL (idl.json):".bold());
        println!("{}", "-".repeat(60));
        println!("{}", idl_json);

        if let Some(ref ts) = ts_output {
            println!("{}", "TypeScript Client (types.ts):".bold());
            println!("{}", "-".repeat(60));
            println!("{}", ts);
        }
    } else {
        // Create output directories
        let programs_dir = output_dir.join("programs").join(&name).join("src");
        let idl_dir = output_dir.join("target").join("idl");

        fs::create_dir_all(&programs_dir)?;
        fs::create_dir_all(&idl_dir)?;

        // Write Rust program
        let rust_path = programs_dir.join("lib.rs");
        fs::write(&rust_path, &rust_output)?;
        println!("{:>12} {}", "Generated".green().bold(), rust_path.display());

        // Write IDL
        let idl_path = idl_dir.join(format!("{}.json", name));
        fs::write(&idl_path, &idl_json)?;
        println!("{:>12} {}", "Generated".green().bold(), idl_path.display());

        // Write TypeScript
        if let Some(ref ts) = ts_output {
            let app_dir = output_dir.join("app").join("src");
            fs::create_dir_all(&app_dir)?;

            let ts_path = app_dir.join("types.ts");
            fs::write(&ts_path, ts)?;
            println!("{:>12} {}", "Generated".green().bold(), ts_path.display());
        }
    }

    // Print summary
    println!();
    println!("{}", "Summary:".bold());
    println!("  Program: {}", name.cyan());
    println!("  Version: {}", version);
    println!("  Accounts: {}", accounts.len());
    println!("  Instructions: {}", instructions.len());
    println!("  Other types: {}", other_types.len());

    if !dry_run {
        println!();
        println!("{}", "Next steps:".bold());
        println!("  1. Update declare_id!() with your program address");
        println!("  2. Implement instruction handlers");
        println!("  3. Run `anchor build` to compile");
        println!("  4. Run `anchor test` to verify");
    }

    Ok(())
}
