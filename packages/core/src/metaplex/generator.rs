// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Metaplex-compatible code generator
//!
//! Generates Rust and TypeScript code that is compatible with Metaplex SDKs.

#[cfg(test)]
use crate::ir::EnumVariantDefinition;
use crate::ir::{EnumDefinition, StructDefinition, TypeDefinition, TypeInfo};

use super::types::constraints;

/// Configuration for Metaplex code generation
#[derive(Debug, Clone)]
pub struct MetaplexGeneratorConfig {
    /// Include mpl-token-metadata imports
    pub include_mpl_imports: bool,

    /// Generate validation helpers
    pub generate_validators: bool,

    /// Generate TypeScript @metaplex-foundation/js compatible types
    pub typescript_sdk_compat: bool,
}

impl Default for MetaplexGeneratorConfig {
    fn default() -> Self {
        Self {
            include_mpl_imports: true,
            generate_validators: true,
            typescript_sdk_compat: true,
        }
    }
}

/// Metaplex code generator
pub struct MetaplexGenerator {
    config: MetaplexGeneratorConfig,
}

impl MetaplexGenerator {
    /// Create a new generator with default config
    pub fn new() -> Self {
        Self {
            config: MetaplexGeneratorConfig::default(),
        }
    }

    /// Create with custom config
    pub fn with_config(config: MetaplexGeneratorConfig) -> Self {
        Self { config }
    }

    /// Generate Rust code for Metaplex types
    pub fn generate_rust(&self, types: &[TypeDefinition]) -> String {
        let mut output = String::new();

        // Header
        output.push_str("// Auto-generated by LUMOS for Metaplex Token Metadata\n");
        output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

        // Imports
        if self.config.include_mpl_imports {
            output.push_str("use borsh::{BorshDeserialize, BorshSerialize};\n");
            output.push_str("use solana_program::pubkey::Pubkey;\n");
            output.push_str("// For full Metaplex compatibility, also use:\n");
            output.push_str("// use mpl_token_metadata::state::*;\n");
            output.push_str("\n");
        }

        // Constants
        output.push_str(&self.generate_rust_constants());
        output.push('\n');

        // Generate types
        for type_def in types {
            match type_def {
                TypeDefinition::Struct(s) => {
                    output.push_str(&self.generate_rust_struct(s));
                    output.push('\n');
                }
                TypeDefinition::Enum(e) => {
                    output.push_str(&self.generate_rust_enum(e));
                    output.push('\n');
                }
                TypeDefinition::TypeAlias(_) => {}
            }
        }

        // Validators
        if self.config.generate_validators {
            output.push_str(&self.generate_rust_validators());
        }

        output
    }

    /// Generate Rust constants
    fn generate_rust_constants(&self) -> String {
        format!(
            r#"/// Metaplex Token Metadata constraints
pub mod metaplex_constraints {{
    /// Maximum length for NFT name
    pub const MAX_NAME_LENGTH: usize = {};
    /// Maximum length for NFT symbol
    pub const MAX_SYMBOL_LENGTH: usize = {};
    /// Maximum length for NFT URI
    pub const MAX_URI_LENGTH: usize = {};
    /// Maximum number of creators
    pub const MAX_CREATORS: usize = {};
    /// Maximum seller fee (100% = 10000)
    pub const MAX_SELLER_FEE_BASIS_POINTS: u16 = {};
}}
"#,
            constraints::MAX_NAME_LENGTH,
            constraints::MAX_SYMBOL_LENGTH,
            constraints::MAX_URI_LENGTH,
            constraints::MAX_CREATORS,
            constraints::MAX_SELLER_FEE_BASIS_POINTS,
        )
    }

    /// Generate a Rust struct
    fn generate_rust_struct(&self, struct_def: &StructDefinition) -> String {
        let mut output = String::new();
        let name = &struct_def.name;

        // Check if this is a metaplex type
        let is_metadata = name.contains("Metadata");
        let is_creator = name == "Creator";

        // Doc comment
        if is_metadata {
            output.push_str("/// Metaplex Token Metadata compatible struct\n");
        } else if is_creator {
            output.push_str("/// Metaplex Creator struct\n");
        }

        // Derives
        output.push_str("#[derive(Debug, Clone, BorshSerialize, BorshDeserialize)]\n");

        // Struct definition
        output.push_str(&format!("pub struct {} {{\n", name));

        for field in &struct_def.fields {
            // Field doc for metadata fields
            if is_metadata {
                match field.name.as_str() {
                    "name" => output.push_str(&format!(
                        "    /// NFT name (max {} chars)\n",
                        constraints::MAX_NAME_LENGTH
                    )),
                    "symbol" => output.push_str(&format!(
                        "    /// NFT symbol (max {} chars)\n",
                        constraints::MAX_SYMBOL_LENGTH
                    )),
                    "uri" => output.push_str(&format!(
                        "    /// Metadata URI (max {} chars)\n",
                        constraints::MAX_URI_LENGTH
                    )),
                    "seller_fee_basis_points" => {
                        output.push_str("    /// Royalty percentage (100% = 10000)\n")
                    }
                    "creators" => output.push_str(&format!(
                        "    /// NFT creators (max {})\n",
                        constraints::MAX_CREATORS
                    )),
                    _ => {}
                }
            }

            output.push_str(&format!(
                "    pub {}: {},\n",
                field.name,
                self.rust_type(&field.type_info)
            ));
        }

        output.push_str("}\n");
        output
    }

    /// Generate a Rust enum
    fn generate_rust_enum(&self, enum_def: &EnumDefinition) -> String {
        let mut output = String::new();

        output.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, BorshSerialize, BorshDeserialize)]\n");
        output.push_str(&format!("pub enum {} {{\n", enum_def.name));

        for (i, variant) in enum_def.variants.iter().enumerate() {
            let variant_name = variant.name();
            output.push_str(&format!("    {} = {},\n", variant_name, i));
        }

        output.push_str("}\n");
        output
    }

    /// Generate Rust validation helpers
    fn generate_rust_validators(&self) -> String {
        r#"
/// Validation helpers for Metaplex metadata
pub mod metaplex_validation {
    use super::metaplex_constraints::*;

    /// Validate NFT name length
    pub fn validate_name(name: &str) -> Result<(), String> {
        if name.len() > MAX_NAME_LENGTH {
            Err(format!("Name exceeds {} characters", MAX_NAME_LENGTH))
        } else {
            Ok(())
        }
    }

    /// Validate NFT symbol length
    pub fn validate_symbol(symbol: &str) -> Result<(), String> {
        if symbol.len() > MAX_SYMBOL_LENGTH {
            Err(format!("Symbol exceeds {} characters", MAX_SYMBOL_LENGTH))
        } else {
            Ok(())
        }
    }

    /// Validate URI length
    pub fn validate_uri(uri: &str) -> Result<(), String> {
        if uri.len() > MAX_URI_LENGTH {
            Err(format!("URI exceeds {} characters", MAX_URI_LENGTH))
        } else {
            Ok(())
        }
    }

    /// Validate seller fee basis points
    pub fn validate_seller_fee(fee: u16) -> Result<(), String> {
        if fee > MAX_SELLER_FEE_BASIS_POINTS {
            Err(format!("Seller fee exceeds maximum of {}", MAX_SELLER_FEE_BASIS_POINTS))
        } else {
            Ok(())
        }
    }

    /// Validate creator shares sum to 100
    pub fn validate_creator_shares(shares: &[u8]) -> Result<(), String> {
        let total: u16 = shares.iter().map(|&s| s as u16).sum();
        if total != 100 {
            Err(format!("Creator shares sum to {} instead of 100", total))
        } else {
            Ok(())
        }
    }

    /// Validate creator count
    pub fn validate_creator_count(count: usize) -> Result<(), String> {
        if count > MAX_CREATORS {
            Err(format!("Too many creators: {} (max {})", count, MAX_CREATORS))
        } else {
            Ok(())
        }
    }
}
"#
        .to_string()
    }

    /// Convert TypeInfo to Rust type string
    fn rust_type(&self, type_info: &TypeInfo) -> String {
        match type_info {
            TypeInfo::Primitive(name) => match name.as_str() {
                "PublicKey" => "Pubkey".to_string(),
                "Signature" => "[u8; 64]".to_string(),
                _ => name.clone(),
            },
            TypeInfo::Generic(name) => name.clone(),
            TypeInfo::UserDefined(name) => name.clone(),
            TypeInfo::Array(inner) => format!("Vec<{}>", self.rust_type(inner)),
            TypeInfo::FixedArray { element, size } => {
                format!("[{}; {}]", self.rust_type(element), size)
            }
            TypeInfo::Option(inner) => format!("Option<{}>", self.rust_type(inner)),
        }
    }

    /// Generate TypeScript code for Metaplex types
    pub fn generate_typescript(&self, types: &[TypeDefinition]) -> String {
        let mut output = String::new();

        // Header
        output.push_str("// Auto-generated by LUMOS for Metaplex Token Metadata\n");
        output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

        // Imports
        if self.config.typescript_sdk_compat {
            output.push_str("import { PublicKey } from '@solana/web3.js';\n");
            output.push_str("import * as borsh from '@coral-xyz/borsh';\n");
            output.push_str("// For full Metaplex SDK compatibility:\n");
            output.push_str("// import { Metadata } from '@metaplex-foundation/mpl-token-metadata';\n");
            output.push_str("\n");
        }

        // Constants
        output.push_str(&self.generate_typescript_constants());
        output.push('\n');

        // Generate types
        for type_def in types {
            match type_def {
                TypeDefinition::Struct(s) => {
                    output.push_str(&self.generate_typescript_interface(s));
                    output.push('\n');
                }
                TypeDefinition::Enum(e) => {
                    output.push_str(&self.generate_typescript_enum(e));
                    output.push('\n');
                }
                TypeDefinition::TypeAlias(_) => {}
            }
        }

        // Validators
        if self.config.generate_validators {
            output.push_str(&self.generate_typescript_validators());
        }

        output
    }

    /// Generate TypeScript constants
    fn generate_typescript_constants(&self) -> String {
        format!(
            r#"/** Metaplex Token Metadata constraints */
export const METAPLEX_CONSTRAINTS = {{
  /** Maximum length for NFT name */
  MAX_NAME_LENGTH: {},
  /** Maximum length for NFT symbol */
  MAX_SYMBOL_LENGTH: {},
  /** Maximum length for NFT URI */
  MAX_URI_LENGTH: {},
  /** Maximum number of creators */
  MAX_CREATORS: {},
  /** Maximum seller fee (100% = 10000) */
  MAX_SELLER_FEE_BASIS_POINTS: {},
}} as const;
"#,
            constraints::MAX_NAME_LENGTH,
            constraints::MAX_SYMBOL_LENGTH,
            constraints::MAX_URI_LENGTH,
            constraints::MAX_CREATORS,
            constraints::MAX_SELLER_FEE_BASIS_POINTS,
        )
    }

    /// Generate TypeScript interface
    fn generate_typescript_interface(&self, struct_def: &StructDefinition) -> String {
        let mut output = String::new();
        let name = &struct_def.name;

        let is_metadata = name.contains("Metadata");

        // JSDoc
        if is_metadata {
            output.push_str("/** Metaplex Token Metadata compatible interface */\n");
        }

        output.push_str(&format!("export interface {} {{\n", name));

        for field in &struct_def.fields {
            // Field JSDoc
            if is_metadata {
                match field.name.as_str() {
                    "name" => output.push_str(&format!(
                        "  /** NFT name (max {} chars) */\n",
                        constraints::MAX_NAME_LENGTH
                    )),
                    "symbol" => output.push_str(&format!(
                        "  /** NFT symbol (max {} chars) */\n",
                        constraints::MAX_SYMBOL_LENGTH
                    )),
                    "uri" => output.push_str(&format!(
                        "  /** Metadata URI (max {} chars) */\n",
                        constraints::MAX_URI_LENGTH
                    )),
                    "seller_fee_basis_points" => {
                        output.push_str("  /** @warning u16 precision - royalty (100% = 10000) */\n")
                    }
                    _ => {}
                }
            }

            let ts_type = self.typescript_type(&field.type_info);
            output.push_str(&format!("  {}: {};\n", field.name, ts_type));
        }

        output.push_str("}\n");

        // Also generate Borsh schema
        output.push_str(&self.generate_typescript_borsh_schema(struct_def));

        output
    }

    /// Generate TypeScript Borsh schema
    fn generate_typescript_borsh_schema(&self, struct_def: &StructDefinition) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "\nexport const {}Schema = borsh.struct([\n",
            struct_def.name
        ));

        for field in &struct_def.fields {
            let borsh_type = self.typescript_borsh_type(&field.type_info);
            output.push_str(&format!("  borsh.{}('{}'),\n", borsh_type, field.name));
        }

        output.push_str("]);\n");
        output
    }

    /// Generate TypeScript enum
    fn generate_typescript_enum(&self, enum_def: &EnumDefinition) -> String {
        let mut output = String::new();

        output.push_str(&format!("export enum {} {{\n", enum_def.name));

        for (i, variant) in enum_def.variants.iter().enumerate() {
            let variant_name = variant.name();
            output.push_str(&format!("  {} = {},\n", variant_name, i));
        }

        output.push_str("}\n");
        output
    }

    /// Generate TypeScript validation helpers
    fn generate_typescript_validators(&self) -> String {
        format!(
            r#"
/** Validation helpers for Metaplex metadata */
export const MetaplexValidation = {{
  /** Validate NFT name length */
  validateName(name: string): void {{
    if (name.length > METAPLEX_CONSTRAINTS.MAX_NAME_LENGTH) {{
      throw new Error(`Name exceeds ${{METAPLEX_CONSTRAINTS.MAX_NAME_LENGTH}} characters`);
    }}
  }},

  /** Validate NFT symbol length */
  validateSymbol(symbol: string): void {{
    if (symbol.length > METAPLEX_CONSTRAINTS.MAX_SYMBOL_LENGTH) {{
      throw new Error(`Symbol exceeds ${{METAPLEX_CONSTRAINTS.MAX_SYMBOL_LENGTH}} characters`);
    }}
  }},

  /** Validate URI length */
  validateUri(uri: string): void {{
    if (uri.length > METAPLEX_CONSTRAINTS.MAX_URI_LENGTH) {{
      throw new Error(`URI exceeds ${{METAPLEX_CONSTRAINTS.MAX_URI_LENGTH}} characters`);
    }}
  }},

  /** Validate seller fee basis points */
  validateSellerFee(fee: number): void {{
    if (fee > METAPLEX_CONSTRAINTS.MAX_SELLER_FEE_BASIS_POINTS) {{
      throw new Error(`Seller fee exceeds maximum of ${{METAPLEX_CONSTRAINTS.MAX_SELLER_FEE_BASIS_POINTS}}`);
    }}
  }},

  /** Validate creator shares sum to 100 */
  validateCreatorShares(shares: number[]): void {{
    const total = shares.reduce((a, b) => a + b, 0);
    if (total !== 100) {{
      throw new Error(`Creator shares sum to ${{total}} instead of 100`);
    }}
  }},

  /** Validate creator count */
  validateCreatorCount(count: number): void {{
    if (count > METAPLEX_CONSTRAINTS.MAX_CREATORS) {{
      throw new Error(`Too many creators: ${{count}} (max ${{METAPLEX_CONSTRAINTS.MAX_CREATORS}})`);
    }}
  }},
}};
"#
        )
    }

    /// Convert TypeInfo to TypeScript type
    fn typescript_type(&self, type_info: &TypeInfo) -> String {
        match type_info {
            TypeInfo::Primitive(name) => match name.as_str() {
                "u8" | "u16" | "u32" | "i8" | "i16" | "i32" => "number".to_string(),
                "u64" | "i64" | "u128" | "i128" => "bigint".to_string(),
                "bool" => "boolean".to_string(),
                "String" => "string".to_string(),
                "PublicKey" => "PublicKey".to_string(),
                "Signature" => "Uint8Array".to_string(),
                _ => name.clone(),
            },
            TypeInfo::Generic(name) => name.clone(),
            TypeInfo::UserDefined(name) => name.clone(),
            TypeInfo::Array(inner) => format!("{}[]", self.typescript_type(inner)),
            TypeInfo::Option(inner) => format!("{} | null", self.typescript_type(inner)),
            TypeInfo::FixedArray { element, .. } => format!("{}[]", self.typescript_type(element)),
        }
    }

    /// Convert TypeInfo to Borsh type string
    fn typescript_borsh_type(&self, type_info: &TypeInfo) -> String {
        match type_info {
            TypeInfo::Primitive(name) => match name.as_str() {
                "u8" => "u8".to_string(),
                "u16" => "u16".to_string(),
                "u32" => "u32".to_string(),
                "u64" => "u64".to_string(),
                "u128" => "u128".to_string(),
                "i8" => "i8".to_string(),
                "i16" => "i16".to_string(),
                "i32" => "i32".to_string(),
                "i64" => "i64".to_string(),
                "i128" => "i128".to_string(),
                "bool" => "bool".to_string(),
                "String" => "str".to_string(),
                "PublicKey" => "publicKey".to_string(),
                "Signature" => "array(u8, 64)".to_string(),
                _ => name.clone(),
            },
            TypeInfo::Generic(name) => name.clone(),
            TypeInfo::UserDefined(name) => format!("{}Schema", name),
            TypeInfo::Array(inner) => format!("vec({})", self.typescript_borsh_type(inner)),
            TypeInfo::Option(inner) => format!("option({})", self.typescript_borsh_type(inner)),
            TypeInfo::FixedArray { element, size } => {
                format!("array({}, {})", self.typescript_borsh_type(element), size)
            }
        }
    }
}

impl Default for MetaplexGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, Visibility};

    fn create_test_metadata() -> StructDefinition {
        StructDefinition {
            name: "TokenMetadata".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "symbol".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "uri".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "seller_fee_basis_points".to_string(),
                    type_info: TypeInfo::Primitive("u16".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,
            module_path: vec![],
        }
    }

    #[test]
    fn test_generate_rust() {
        let generator = MetaplexGenerator::new();
        let types = vec![TypeDefinition::Struct(create_test_metadata())];

        let rust = generator.generate_rust(&types);

        assert!(rust.contains("pub struct TokenMetadata"));
        assert!(rust.contains("pub name: String"));
        assert!(rust.contains("pub seller_fee_basis_points: u16"));
        assert!(rust.contains("MAX_NAME_LENGTH: usize = 32"));
        assert!(rust.contains("validate_name"));
    }

    #[test]
    fn test_generate_typescript() {
        let generator = MetaplexGenerator::new();
        let types = vec![TypeDefinition::Struct(create_test_metadata())];

        let ts = generator.generate_typescript(&types);

        assert!(ts.contains("export interface TokenMetadata"));
        assert!(ts.contains("name: string"));
        assert!(ts.contains("seller_fee_basis_points: number"));
        assert!(ts.contains("MAX_NAME_LENGTH: 32"));
        assert!(ts.contains("validateName"));
    }

    #[test]
    fn test_generate_rust_enum() {
        let generator = MetaplexGenerator::new();
        let enum_def = EnumDefinition {
            name: "TokenStandard".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "NonFungible".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Fungible".to_string(),
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,
            module_path: vec![],
        };
        let types = vec![TypeDefinition::Enum(enum_def)];

        let rust = generator.generate_rust(&types);

        assert!(rust.contains("pub enum TokenStandard"));
        assert!(rust.contains("NonFungible = 0"));
        assert!(rust.contains("Fungible = 1"));
    }

    #[test]
    fn test_rust_type_mapping() {
        let generator = MetaplexGenerator::new();

        assert_eq!(
            generator.rust_type(&TypeInfo::Primitive("u8".to_string())),
            "u8"
        );
        assert_eq!(
            generator.rust_type(&TypeInfo::Primitive("PublicKey".to_string())),
            "Pubkey"
        );
        assert_eq!(
            generator.rust_type(&TypeInfo::Array(Box::new(TypeInfo::Primitive(
                "u8".to_string()
            )))),
            "Vec<u8>"
        );
        assert_eq!(
            generator.rust_type(&TypeInfo::Option(Box::new(TypeInfo::Primitive(
                "String".to_string()
            )))),
            "Option<String>"
        );
    }

    #[test]
    fn test_typescript_type_mapping() {
        let generator = MetaplexGenerator::new();

        assert_eq!(
            generator.typescript_type(&TypeInfo::Primitive("u16".to_string())),
            "number"
        );
        assert_eq!(
            generator.typescript_type(&TypeInfo::Primitive("u64".to_string())),
            "bigint"
        );
        assert_eq!(
            generator.typescript_type(&TypeInfo::Primitive("PublicKey".to_string())),
            "PublicKey"
        );
        assert_eq!(
            generator.typescript_type(&TypeInfo::Array(Box::new(TypeInfo::Primitive(
                "String".to_string()
            )))),
            "string[]"
        );
    }
}
