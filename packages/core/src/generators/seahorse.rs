// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Seahorse Python Code Generator
//!
//! Generates Seahorse-compatible Python code from IR for Solana programs
//! written in Python using the Seahorse framework.
//!
//! ## Overview
//!
//! Seahorse is a framework that allows writing Solana programs in Python,
//! which compiles to Anchor-compatible Rust. This generator produces
//! type-safe Python code compatible with Seahorse's type system.
//!
//! ## Key Differences from Standard Python Generator
//!
//! - Uses `from seahorse.prelude import *` for imports
//! - Uses `@account` decorator for account structs
//! - Uses Seahorse-native types (u8, u16, u32, u64, Pubkey, etc.)
//! - No explicit Borsh schemas (Seahorse handles serialization)
//!
//! ## Type Mapping
//!
//! IR types are mapped to Seahorse types:
//!
//! | IR Type | Seahorse Type | Notes |
//! |---------|---------------|-------|
//! | `u8`, `u16`, `u32`, `u64` | `u8`, `u16`, `u32`, `u64` | Native Seahorse types |
//! | `i8`, `i16`, `i32`, `i64` | `i8`, `i16`, `i32`, `i64` | Signed integers |
//! | `u128`, `i128` | `u128`, `i128` | Large integers |
//! | `String` | `str` | Python strings |
//! | `bool` | `bool` | Python booleans |
//! | `PublicKey` | `Pubkey` | Seahorse Pubkey type |
//! | `[T]` | `List[T]` | Dynamic arrays |
//! | `Option<T>` | `T | None` | Optional fields |
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::seahorse};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct PlayerAccount {
//!         wallet: PublicKey,
//!         level: u16,
//!         experience: u64,
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let py_code = seahorse::generate_module(&ir);
//!
//! // Generated Seahorse Python
//! assert!(py_code.contains("from seahorse.prelude import *"));
//! assert!(py_code.contains("@account"));
//! assert!(py_code.contains("class PlayerAccount:"));
//! assert!(py_code.contains("wallet: Pubkey"));
//! assert!(py_code.contains("level: u16"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeAliasDefinition, TypeDefinition,
    TypeInfo,
};

/// Generate Seahorse Python code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
        TypeDefinition::TypeAlias(alias_def) => generate_type_alias(alias_def),
    }
}

/// Generate Seahorse Python code from a type alias definition
fn generate_type_alias(alias_def: &TypeAliasDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS for Seahorse\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    output.push_str("from seahorse.prelude import *\n");
    output.push_str("from typing import TypeAlias\n\n");

    // Generate the type alias
    let py_type = map_type_to_seahorse(&alias_def.target);
    output.push_str(&format!("{}: TypeAlias = {}\n", alias_def.name, py_type));

    output
}

/// Generate Seahorse Python code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS for Seahorse\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    output.push_str("from seahorse.prelude import *\n\n");

    // Generate version constant if version is specified
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = \"{}\"\n\n",
            struct_def.name.to_uppercase(),
            version
        ));
    }

    // Generate class with @account decorator if it's a Solana account
    output.push_str(&generate_struct_class(struct_def));

    output
}

/// Generate Seahorse Python code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS for Seahorse\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    output.push_str("from seahorse.prelude import *\n");

    // Add enum import for unit enums
    if enum_def.is_unit_only() {
        output.push_str("from enum import IntEnum\n");
    } else {
        output.push_str("from dataclasses import dataclass\n");
    }
    output.push('\n');

    // Generate version constant if version is specified
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = \"{}\"\n\n",
            enum_def.name.to_uppercase(),
            version
        ));
    }

    // Generate enum type
    output.push_str(&generate_enum_class(enum_def));

    output
}

/// Estimate output size for string capacity pre-allocation
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 200;
    const STRUCT_BASE: usize = 150;
    const FIELD_SIZE: usize = 60;
    const ENUM_BASE: usize = 150;
    const VARIANT_SIZE: usize = 50;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
            TypeDefinition::TypeAlias(_) => 100,
        };
    }

    total
}

/// Generate Seahorse Python code for a complete module with multiple type definitions.
///
/// This is the primary function for generating Seahorse code from IR.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete Seahorse Python source code as a `String`, ready to write to a `.py` file.
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str("# Auto-generated by LUMOS for Seahorse\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    // Seahorse prelude import
    output.push_str("from seahorse.prelude import *\n");

    // Check if we need additional imports
    let mut needs_int_enum = false;
    let mut needs_dataclass = false;
    let mut needs_type_alias = false;

    for type_def in type_defs {
        match type_def {
            TypeDefinition::Enum(e) => {
                if e.is_unit_only() {
                    needs_int_enum = true;
                } else {
                    needs_dataclass = true;
                }
            }
            TypeDefinition::TypeAlias(_) => {
                needs_type_alias = true;
            }
            _ => {}
        }
    }

    if needs_int_enum {
        output.push_str("from enum import IntEnum\n");
    }
    if needs_dataclass {
        output.push_str("from dataclasses import dataclass\n");
    }
    if needs_type_alias {
        output.push_str("from typing import TypeAlias\n");
    }
    output.push('\n');

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                // Generate version constant if present
                if let Some(version) = &s.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = \"{}\"\n\n",
                        s.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_struct_class(s));
            }
            TypeDefinition::Enum(e) => {
                // Generate version constant if present
                if let Some(version) = &e.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = \"{}\"\n\n",
                        e.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_enum_class(e));
            }
            TypeDefinition::TypeAlias(a) => {
                let py_type = map_type_to_seahorse(&a.target);
                output.push_str(&format!("{}: TypeAlias = {}\n", a.name, py_type));
            }
        }
    }

    output
}

/// Generate Seahorse class for struct
fn generate_struct_class(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Use @account decorator for account structs
    let is_account = struct_def
        .metadata
        .attributes
        .contains(&"account".to_string());
    if is_account {
        output.push_str("@account\n");
    }

    output.push_str(&format!("class {}:\n", struct_def.name));

    if struct_def.fields.is_empty() {
        output.push_str("    pass\n");
    } else {
        // Add docstring if we have deprecation warnings
        let deprecated_fields: Vec<_> = struct_def
            .fields
            .iter()
            .filter(|f| f.deprecated.is_some())
            .collect();

        if !deprecated_fields.is_empty() {
            output.push_str("    \"\"\"\n");
            output.push_str("    Deprecated fields:\n");
            for field in &deprecated_fields {
                if let Some(msg) = &field.deprecated {
                    output.push_str(&format!("    - {}: {}\n", field.name, msg));
                } else {
                    output.push_str(&format!("    - {}: deprecated\n", field.name));
                }
            }
            output.push_str("    \"\"\"\n");
        }

        // Generate fields with Seahorse types
        for field in &struct_def.fields {
            let py_type = map_type_to_seahorse(&field.type_info);
            // Handle optional fields
            let type_annotation =
                if field.optional && !matches!(&field.type_info, TypeInfo::Option(_)) {
                    format!("{} | None", py_type)
                } else {
                    py_type
                };

            output.push_str(&format!("    {}: {}\n", field.name, type_annotation));
        }
    }

    output
}

/// Generate Seahorse enum class
fn generate_enum_class(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Check if all variants are unit variants (simple IntEnum)
    if enum_def.is_unit_only() {
        output.push_str(&format!("class {}(IntEnum):\n", enum_def.name));
        for (idx, variant) in enum_def.variants.iter().enumerate() {
            if let EnumVariantDefinition::Unit { name } = variant {
                output.push_str(&format!("    {} = {}\n", name, idx));
            }
        }
    } else {
        // Complex enum with variants - use tagged union pattern
        output.push_str("# Variant types\n");

        // Generate variant dataclasses
        for variant in &enum_def.variants {
            match variant {
                EnumVariantDefinition::Unit { name } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    output.push_str("    pass\n\n");
                }
                EnumVariantDefinition::Tuple { name, types } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    for (idx, type_info) in types.iter().enumerate() {
                        let py_type = map_type_to_seahorse(type_info);
                        output.push_str(&format!("    field{}: {}\n", idx, py_type));
                    }
                    output.push('\n');
                }
                EnumVariantDefinition::Struct { name, fields } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    if fields.is_empty() {
                        output.push_str("    pass\n\n");
                    } else {
                        for field in fields {
                            let py_type = map_type_to_seahorse(&field.type_info);
                            output.push_str(&format!("    {}: {}\n", field.name, py_type));
                        }
                        output.push('\n');
                    }
                }
            }
        }

        // Generate union type alias
        let variant_names: Vec<String> = enum_def
            .variants
            .iter()
            .map(|v| format!("{}{}", enum_def.name, v.name()))
            .collect();
        output.push_str(&format!(
            "{} = {}\n",
            enum_def.name,
            variant_names.join(" | ")
        ));
    }

    output
}

/// Map IR type to Seahorse type
///
/// Seahorse uses its own type annotations that map directly to Rust types
fn map_type_to_seahorse(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            match type_name.as_str() {
                // Seahorse uses Rust-style integer types
                "u8" => "u8".to_string(),
                "u16" => "u16".to_string(),
                "u32" => "u32".to_string(),
                "u64" => "u64".to_string(),
                "u128" => "u128".to_string(),
                "i8" => "i8".to_string(),
                "i16" => "i16".to_string(),
                "i32" => "i32".to_string(),
                "i64" => "i64".to_string(),
                "i128" => "i128".to_string(),

                // Floating point
                "f32" => "f32".to_string(),
                "f64" => "f64".to_string(),

                // Boolean
                "bool" => "bool".to_string(),

                // String
                "String" => "str".to_string(),

                // Solana types - Seahorse uses Pubkey
                "Pubkey" | "PublicKey" => "Pubkey".to_string(),
                "Signature" => "str".to_string(),

                // Unknown - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_seahorse(inner);
            format!("List[{}]", inner_type)
        }
        TypeInfo::FixedArray { element, size } => {
            let element_type = map_type_to_seahorse(element);
            format!("Array[{}, {}]", element_type, size)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_seahorse(inner);
            format!("{} | None", inner_type)
        }
        TypeInfo::Generic(param_name) => param_name.clone(),
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, StructDefinition, TypeDefinition, Visibility};

    #[test]
    fn generates_account_class() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "PlayerAccount".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "level".to_string(),
                    type_info: TypeInfo::Primitive("u16".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "experience".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from seahorse.prelude import *"));
        assert!(code.contains("@account"));
        assert!(code.contains("class PlayerAccount:"));
        assert!(code.contains("wallet: Pubkey"));
        assert!(code.contains("level: u16"));
        assert!(code.contains("experience: u64"));
    }

    #[test]
    fn generates_non_account_class() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "GameConfig".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "max_players".to_string(),
                type_info: TypeInfo::Primitive("u32".to_string()),
                optional: false,
                deprecated: None,
                span: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![], // No "account" attribute
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from seahorse.prelude import *"));
        assert!(!code.contains("@account")); // No @account decorator
        assert!(code.contains("class GameConfig:"));
        assert!(code.contains("max_players: u32"));
    }

    #[test]
    fn maps_seahorse_types_correctly() {
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("u8".to_string())),
            "u8"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("u16".to_string())),
            "u16"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("u64".to_string())),
            "u64"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("i64".to_string())),
            "i64"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("bool".to_string())),
            "bool"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("String".to_string())),
            "str"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Primitive("PublicKey".to_string())),
            "Pubkey"
        );
    }

    #[test]
    fn maps_complex_types() {
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Array(Box::new(TypeInfo::Primitive(
                "u64".to_string()
            )))),
            "List[u64]"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::Option(Box::new(TypeInfo::Primitive(
                "u64".to_string()
            )))),
            "u64 | None"
        );
        assert_eq!(
            map_type_to_seahorse(&TypeInfo::FixedArray {
                element: Box::new(TypeInfo::Primitive("u8".to_string())),
                size: 32
            }),
            "Array[u8, 32]"
        );
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "PlayerAccount".to_string(),
                generic_params: vec![],
                fields: vec![FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("Pubkey".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                }],
                metadata: Metadata {
                    solana: true,
                    attributes: vec!["account".to_string()],
                    version: None,
                    custom_derives: vec![],
                    is_instruction: false,
                    anchor_attrs: vec![],
                },
                visibility: Visibility::Public,
                module_path: Vec::new(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "GameState".to_string(),
                generic_params: vec![],
                fields: vec![FieldDefinition {
                    name: "is_active".to_string(),
                    type_info: TypeInfo::Primitive("bool".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                }],
                metadata: Metadata {
                    solana: true,
                    attributes: vec!["account".to_string()],
                    version: None,
                    custom_derives: vec![],
                    is_instruction: false,
                    anchor_attrs: vec![],
                },
                visibility: Visibility::Public,
                module_path: Vec::new(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("from seahorse.prelude import *"));
        assert!(code.contains("@account\nclass PlayerAccount:"));
        assert!(code.contains("@account\nclass GameState:"));
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(crate::ir::EnumDefinition {
            name: "Status".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Ended".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from enum import IntEnum"));
        assert!(code.contains("class Status(IntEnum):"));
        assert!(code.contains("Active = 0"));
        assert!(code.contains("Paused = 1"));
        assert!(code.contains("Ended = 2"));
    }

    #[test]
    fn handles_deprecated_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    span: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "old_field".to_string(),
                    type_info: TypeInfo::Primitive("u32".to_string()),
                    optional: false,
                    deprecated: Some("Use new_field instead".to_string()),
                    span: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("Deprecated fields:"));
        assert!(code.contains("old_field: Use new_field instead"));
    }
}
