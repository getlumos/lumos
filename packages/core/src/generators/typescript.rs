// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! TypeScript Code Generator
//!
//! Generates TypeScript interfaces and Borsh schemas from IR for client-side Solana
//! integration with guaranteed serialization compatibility.
//!
//! ## Overview
//!
//! This generator produces type-safe TypeScript code for Solana dApp frontends with:
//!
//! - **TypeScript Interfaces** - Type-safe data structures for IDE support
//! - **Borsh Schemas** - Serialization/deserialization compatible with Rust on-chain code
//! - **Discriminated Unions** - Type-safe enums with `kind` field for narrowing
//! - **Solana Web3.js Integration** - Automatic imports for `PublicKey`, `Keypair`
//!
//! ## Discriminated Union Pattern (Enums)
//!
//! Rust enums are mapped to TypeScript discriminated unions with a `kind` field:
//!
//! ```rust,ignore
//! // LUMOS schema
//! enum GameState {
//!     Active,
//!     Paused,
//!     Finished,
//! }
//! ```
//!
//! ```typescript
//! // Generated TypeScript
//! export type GameState =
//!   | { kind: 'Active' }
//!   | { kind: 'Paused' }
//!   | { kind: 'Finished' };
//! ```
//!
//! ## Type Mapping
//!
//! IR types are mapped to TypeScript types:
//!
//! | IR Type | TypeScript | Borsh Schema | Notes |
//! |---------|------------|--------------|-------|
//! | `u8`, `u16`, `u32`, `u64` | `number` | `borsh.u64`, etc. | Safe for values < 2^53 |
//! | `u128`, `i128` | `bigint` | `borsh.u128`, `borsh.i128` | Native BigInt support |
//! | `String` | `string` | `borsh.string` | UTF-8 strings |
//! | `bool` | `boolean` | `borsh.bool` | - |
//! | `PublicKey` | `PublicKey` | `borsh.publicKey` | From `@solana/web3.js` |
//! | `[T]` | `T[]` | `borsh.vec(...)` | Dynamic arrays |
//! | `Option<T>` | `T \| undefined` | `borsh.option(...)` | Optional fields |
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::typescript};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct UserAccount {
//!         wallet: PublicKey,
//!         balance: u64,
//!         items: [PublicKey],
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let ts_code = typescript::generate_module(&ir);
//!
//! // Generated TypeScript includes interface + Borsh schema
//! assert!(ts_code.contains("export interface UserAccount"));
//! assert!(ts_code.contains("export const UserAccountSchema = borsh.struct"));
//! assert!(ts_code.contains("borsh.publicKey('wallet')"));
//! assert!(ts_code.contains("borsh.u64('balance')"));
//! assert!(ts_code.contains("borsh.vec(borsh.publicKey)('items')"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeAliasDefinition, TypeDefinition,
    TypeInfo,
};
use std::collections::HashSet;

/// Generate TypeScript code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
        TypeDefinition::TypeAlias(alias_def) => generate_type_alias(alias_def),
    }
}

/// Generate TypeScript code from a type alias definition
fn generate_type_alias(alias_def: &TypeAliasDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports for the target type
    let mut needs_publickey = false;
    collect_imports_from_type(&alias_def.target, &mut needs_publickey);

    if needs_publickey {
        output.push_str("import { PublicKey } from '@solana/web3.js';\n\n");
    }

    // Generate the type alias
    let ts_type = map_type_to_typescript(&alias_def.target);
    output.push_str(&format!("export type {} = {};\n", alias_def.name, ts_type));

    output
}

/// Generate TypeScript code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_struct_imports(struct_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "export const {}_VERSION = \"{}\";\n\n",
            struct_def.name.to_uppercase(),
            version
        ));
    }

    // Generate interface
    output.push_str(&generate_struct_interface(struct_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if struct_def.metadata.solana {
        output.push_str(&generate_struct_borsh_schema(struct_def));
    }

    output
}

/// Generate TypeScript code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_enum_imports(enum_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "export const {}_VERSION = \"{}\";\n\n",
            enum_def.name.to_uppercase(),
            version
        ));
    }

    // Generate discriminated union type
    output.push_str(&generate_enum_type(enum_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if enum_def.metadata.solana {
        output.push_str(&generate_enum_borsh_schema(enum_def));
    }

    output
}

/// Generate TypeScript code for a complete module with multiple type definitions.
///
/// This is the primary function for generating TypeScript code from IR. It handles
/// import management, interface generation, and Borsh schema creation for all types.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete TypeScript source code as a `String`, ready to write to a `.ts` file.
/// Includes:
/// - Auto-generated file header
/// - Optimized imports (`@solana/web3.js`, `@coral-xyz/borsh`)
/// - TypeScript interfaces for structs
/// - Discriminated union types for enums
/// - Borsh schemas for Solana types (serialization/deserialization)
///
/// # Import Management
///
/// The function analyzes all types to determine required imports:
///
/// - `import { PublicKey } from '@solana/web3.js'` - When `PublicKey` or `Pubkey` types detected
/// - `import * as borsh from '@coral-xyz/borsh'` - For Solana types (with `#[solana]` attribute)
///
/// # Enum Generation Strategy
///
/// Enums are converted to TypeScript discriminated unions with a `kind` field for type narrowing:
///
/// - **Unit variants**: `{ kind: 'VariantName' }`
/// - **Tuple variants**: `{ kind: 'VariantName'; field0: Type; field1: Type }`
/// - **Struct variants**: `{ kind: 'VariantName'; fieldName: Type }`
///
/// This enables TypeScript's type narrowing for safe pattern matching.
///
/// # Example
///
/// ```rust
/// use lumos_core::{parser, transform, generators::typescript};
///
/// let source = r#"
///     #[solana]
///     #[account]
///     struct UserAccount {
///         wallet: PublicKey,
///         balance: u64,
///     }
///
///     #[solana]
///     enum GameState {
///         Active,
///         Paused,
///         Finished,
///     }
/// "#;
///
/// let ast = parser::parse_lumos_file(source)?;
/// let ir = transform::transform_to_ir(ast)?;
/// let ts_code = typescript::generate_module(&ir);
///
/// // Includes necessary imports
/// assert!(ts_code.contains("import { PublicKey } from '@solana/web3.js'"));
/// assert!(ts_code.contains("import * as borsh from '@coral-xyz/borsh'"));
///
/// // Struct interface + Borsh schema
/// assert!(ts_code.contains("export interface UserAccount"));
/// assert!(ts_code.contains("export const UserAccountSchema = borsh.struct"));
///
/// // Enum discriminated union + Borsh schema
/// assert!(ts_code.contains("export type GameState ="));
/// assert!(ts_code.contains("{ kind: 'Active' }"));
/// assert!(ts_code.contains("export const GameStateSchema = borsh.rustEnum"));
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
///
/// # Generated Code Structure
///
/// ```typescript
/// // Auto-generated by LUMOS
/// // DO NOT EDIT - Changes will be overwritten
///
/// import { PublicKey } from '@solana/web3.js';
/// import * as borsh from '@coral-xyz/borsh';
///
/// export interface UserAccount {
///   wallet: PublicKey;
///   balance: number;
/// }
///
/// export const UserAccountSchema = borsh.struct([
///   borsh.publicKey('wallet'),
///   borsh.u64('balance'),
/// ]);
///
/// export type GameState =
///   | { kind: 'Active' }
///   | { kind: 'Paused' }
///   | { kind: 'Finished' };
///
/// export const GameStateSchema = borsh.rustEnum([
///   borsh.unit('Active'),
///   borsh.unit('Paused'),
///   borsh.unit('Finished'),
/// ]);
/// ```
// Estimate output size for string capacity pre-allocation
//
// Reduces reallocations for large schemas by estimating the final size.
// Conservative estimate to avoid excessive over-allocation.
//
// # Estimation Formula
//
// - Base overhead: ~250 bytes (header, imports)
// - Per struct: ~180 bytes + (fields × 70 bytes) [includes Borsh schema]
// - Per enum: ~150 bytes + (variants × 60 bytes) [includes Borsh schema]
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 250;
    const STRUCT_BASE: usize = 180;
    const FIELD_SIZE: usize = 70;
    const ENUM_BASE: usize = 150;
    const VARIANT_SIZE: usize = 60;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
            TypeDefinition::TypeAlias(_) => 100, // Type aliases are small (~50-150 chars)
        };
    }

    total
}

pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    // Estimate output size to reduce allocations for large schemas
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect all imports needed
    let mut all_imports = HashSet::new();
    for type_def in type_defs {
        match type_def {
            TypeDefinition::Struct(s) => {
                let imports = collect_struct_imports(s);
                all_imports.extend(imports);
            }
            TypeDefinition::Enum(e) => {
                let imports = collect_enum_imports(e);
                all_imports.extend(imports);
            }
            TypeDefinition::TypeAlias(a) => {
                // Check if alias target needs imports
                let mut needs_publickey = false;
                collect_imports_from_type(&a.target, &mut needs_publickey);
                if needs_publickey {
                    all_imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
                }
            }
        }
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                // Generate version constant if present
                if let Some(version) = &s.metadata.version {
                    output.push_str(&format!(
                        "export const {}_VERSION = \"{}\";\n\n",
                        s.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_struct_interface(s));

                // Add Borsh schema for Solana types
                if s.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_struct_borsh_schema(s));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
            TypeDefinition::Enum(e) => {
                // Generate version constant if present
                if let Some(version) = &e.metadata.version {
                    output.push_str(&format!(
                        "export const {}_VERSION = \"{}\";\n\n",
                        e.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_enum_type(e));

                // Add Borsh schema for Solana types
                if e.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_enum_borsh_schema(e));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
            TypeDefinition::TypeAlias(a) => {
                // Generate type alias (simple export)
                let ts_type = map_type_to_typescript(&a.target);
                output.push_str(&format!("export type {} = {};\n", a.name, ts_type));
            }
        }
    }

    output
}

/// Check if a TypeInfo contains u64 or i64 types (which map to TypeScript 'number' with precision limits)
fn contains_u64_or_i64(type_info: &TypeInfo) -> bool {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            matches!(type_name.as_str(), "u64" | "i64")
        }
        TypeInfo::Generic(_) => false, // Generic parameters are not u64/i64
        TypeInfo::Array(inner)
        | TypeInfo::FixedArray { element: inner, .. }
        | TypeInfo::Option(inner) => contains_u64_or_i64(inner),
        TypeInfo::UserDefined(_) => false, // User-defined types are checked separately
    }
}

/// Generate TypeScript interface for struct
fn generate_struct_interface(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Generate interface with optional generic parameters
    let interface_name_with_generics = if struct_def.generic_params.is_empty() {
        struct_def.name.clone()
    } else {
        format!(
            "{}<{}>",
            struct_def.name,
            struct_def.generic_params.join(", ")
        )
    };
    output.push_str(&format!(
        "export interface {} {{\n",
        interface_name_with_generics
    ));

    // Generate fields
    for field in &struct_def.fields {
        let ts_type = map_type_to_typescript(&field.type_info);
        let optional_marker = if field.optional { "?" } else { "" };

        // Add JSDoc warning for u64/i64 types (precision limitation)
        if contains_u64_or_i64(&field.type_info) {
            output.push_str("  /**\n");
            output.push_str("   * WARNING: TypeScript 'number' has precision limit of 2^53-1 (9,007,199,254,740,991).\n");
            output.push_str(
                "   * For Solana lamports or large values, ensure they stay within safe range.\n",
            );
            output.push_str(
                "   * Values exceeding this limit will lose precision during serialization.\n",
            );
            output.push_str("   */\n");
        }

        output.push_str(&format!(
            "  {}{}: {};\n",
            field.name, optional_marker, ts_type
        ));
    }

    output.push_str("}\n");

    // Generate derive helper functions if custom_derives exist
    if !struct_def.metadata.custom_derives.is_empty() {
        output.push('\n');
        output.push_str(&generate_derive_helpers(struct_def));
    }

    output
}

/// Generate TypeScript helper functions for Rust derives
fn generate_derive_helpers(struct_def: &StructDefinition) -> String {
    let mut output = String::new();
    let name = &struct_def.name;
    let derives = &struct_def.metadata.custom_derives;

    // PartialEq → equals function
    if derives.iter().any(|d| d == "PartialEq" || d == "Eq") {
        output.push_str(&generate_equals_function(struct_def));
        output.push('\n');
    }

    // Hash → hashCode function
    if derives.iter().any(|d| d == "Hash") {
        output.push_str(&generate_hash_function(name));
        output.push('\n');
    }

    // Default → default factory function
    if derives.iter().any(|d| d == "Default") {
        output.push_str(&generate_default_function(struct_def));
        output.push('\n');
    }

    // Ord → compareTo function
    if derives.iter().any(|d| d == "Ord" || d == "PartialOrd") {
        output.push_str(&generate_compare_function(struct_def));
        output.push('\n');
    }

    output
}

/// Generate equals function for PartialEq derive
fn generate_equals_function(struct_def: &StructDefinition) -> String {
    let name = &struct_def.name;
    let mut output = String::new();

    output.push_str(&format!(
        "/** Compare two {} objects for equality (PartialEq derive) */\n",
        name
    ));
    output.push_str(&format!(
        "export function {}Equals(a: {}, b: {}): boolean {{\n",
        to_camel_case(name),
        name,
        name
    ));

    if struct_def.fields.is_empty() {
        output.push_str("  return true;\n");
    } else {
        output.push_str("  return (\n");
        for (i, field) in struct_def.fields.iter().enumerate() {
            let field_name = &field.name;
            let comparison = generate_field_equality(&field.type_info, field_name);
            if i == 0 {
                output.push_str(&format!("    {}", comparison));
            } else {
                output.push_str(&format!(" &&\n    {}", comparison));
            }
        }
        output.push_str("\n  );\n");
    }

    output.push_str("}\n");
    output
}

/// Generate field equality comparison based on type
fn generate_field_equality(type_info: &TypeInfo, field_name: &str) -> String {
    match type_info {
        TypeInfo::Primitive(t) if t == "PublicKey" || t == "Pubkey" => {
            format!("a.{}.equals(b.{})", field_name, field_name)
        }
        TypeInfo::Array(_) => {
            format!(
                "a.{}.length === b.{}.length && a.{}.every((v, i) => v === b.{}[i])",
                field_name, field_name, field_name, field_name
            )
        }
        TypeInfo::Option(inner) => {
            let inner_eq = generate_field_equality(inner, field_name);
            format!(
                "(a.{} === undefined && b.{} === undefined) || (a.{} !== undefined && b.{} !== undefined && {})",
                field_name, field_name, field_name, field_name, inner_eq
            )
        }
        _ => format!("a.{} === b.{}", field_name, field_name),
    }
}

/// Generate hashCode function for Hash derive
fn generate_hash_function(name: &str) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "/** Generate hash code for {} (Hash derive) */\n",
        name
    ));
    output.push_str(&format!(
        "export function {}HashCode(obj: {}): number {{\n",
        to_camel_case(name),
        name
    ));
    output.push_str("  let hash = 0;\n");
    output.push_str("  const str = JSON.stringify(obj);\n");
    output.push_str("  for (let i = 0; i < str.length; i++) {\n");
    output.push_str("    const char = str.charCodeAt(i);\n");
    output.push_str("    hash = ((hash << 5) - hash) + char;\n");
    output.push_str("    hash = hash & hash; // Convert to 32bit integer\n");
    output.push_str("  }\n");
    output.push_str("  return hash;\n");
    output.push_str("}\n");

    output
}

/// Generate default factory function for Default derive
fn generate_default_function(struct_def: &StructDefinition) -> String {
    let name = &struct_def.name;
    let mut output = String::new();

    output.push_str(&format!(
        "/** Create default {} instance (Default derive) */\n",
        name
    ));
    output.push_str(&format!(
        "export function {}Default(): {} {{\n",
        to_camel_case(name),
        name
    ));
    output.push_str("  return {\n");

    for field in &struct_def.fields {
        let default_value = get_default_value(&field.type_info);
        output.push_str(&format!("    {}: {},\n", field.name, default_value));
    }

    output.push_str("  };\n");
    output.push_str("}\n");

    output
}

/// Get default value for a type
fn get_default_value(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(t) => match t.as_str() {
            "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "f32" | "f64" => {
                "0".to_string()
            }
            "u128" | "i128" => "BigInt(0)".to_string(),
            "bool" => "false".to_string(),
            "String" => "\"\"".to_string(),
            "PublicKey" | "Pubkey" => "PublicKey.default()".to_string(),
            _ => "undefined as any".to_string(),
        },
        TypeInfo::Array(_) | TypeInfo::FixedArray { .. } => "[]".to_string(),
        TypeInfo::Option(_) => "undefined".to_string(),
        TypeInfo::Generic(_) => "undefined as any".to_string(),
        TypeInfo::UserDefined(name) => format!("{}Default()", to_camel_case(name)),
    }
}

/// Generate compareTo function for Ord derive
fn generate_compare_function(struct_def: &StructDefinition) -> String {
    let name = &struct_def.name;
    let mut output = String::new();

    output.push_str(&format!(
        "/** Compare two {} objects for ordering (Ord derive) */\n",
        name
    ));
    output.push_str(&format!(
        "export function {}Compare(a: {}, b: {}): number {{\n",
        to_camel_case(name),
        name,
        name
    ));

    if struct_def.fields.is_empty() {
        output.push_str("  return 0;\n");
    } else {
        output.push_str("  let cmp: number;\n");
        for field in &struct_def.fields {
            let comparison = generate_field_comparison(&field.type_info, &field.name);
            output.push_str(&format!("  cmp = {};\n", comparison));
            output.push_str("  if (cmp !== 0) return cmp;\n");
        }
        output.push_str("  return 0;\n");
    }

    output.push_str("}\n");
    output
}

/// Generate field comparison for ordering
fn generate_field_comparison(type_info: &TypeInfo, field_name: &str) -> String {
    match type_info {
        TypeInfo::Primitive(t) => match t.as_str() {
            "String" => format!(
                "a.{}.localeCompare(b.{})",
                field_name, field_name
            ),
            "bool" => format!(
                "(a.{} === b.{} ? 0 : a.{} ? 1 : -1)",
                field_name, field_name, field_name
            ),
            "PublicKey" | "Pubkey" => format!(
                "a.{}.toBuffer().compare(b.{}.toBuffer())",
                field_name, field_name
            ),
            _ => format!(
                "(a.{} < b.{} ? -1 : a.{} > b.{} ? 1 : 0)",
                field_name, field_name, field_name, field_name
            ),
        },
        TypeInfo::Option(_) => format!(
            "(a.{} === undefined ? (b.{} === undefined ? 0 : -1) : (b.{} === undefined ? 1 : (a.{} < b.{} ? -1 : a.{} > b.{} ? 1 : 0)))",
            field_name, field_name, field_name, field_name, field_name, field_name, field_name
        ),
        _ => format!(
            "(a.{} < b.{} ? -1 : a.{} > b.{} ? 1 : 0)",
            field_name, field_name, field_name, field_name
        ),
    }
}

/// Convert PascalCase to camelCase
fn to_camel_case(s: &str) -> String {
    if s.is_empty() {
        return String::new();
    }
    let mut chars = s.chars();
    let first = chars.next().unwrap_or_default().to_lowercase();
    first.chain(chars).collect()
}

/// Generate Borsh schema for struct serialization
fn generate_struct_borsh_schema(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "export const {}Schema = borsh.struct([\n",
        struct_def.name
    ));

    // Generate Borsh field definitions
    for field in &struct_def.fields {
        let borsh_type = map_type_to_borsh(&field.type_info);
        output.push_str(&format!("  {}('{}'),\n", borsh_type, field.name));
    }

    output.push_str("]);\n");

    output
}

/// Generate TypeScript discriminated union type for enum
fn generate_enum_type(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Check if any variant contains u64/i64 types
    let has_u64_i64 = enum_def.variants.iter().any(|variant| match variant {
        EnumVariantDefinition::Unit { .. } => false,
        EnumVariantDefinition::Tuple { types, .. } => types.iter().any(contains_u64_or_i64),
        EnumVariantDefinition::Struct { fields, .. } => {
            fields.iter().any(|f| contains_u64_or_i64(&f.type_info))
        }
    });

    // Add JSDoc warning if enum contains u64/i64
    if has_u64_i64 {
        output.push_str("/**\n");
        output.push_str(" * WARNING: Some variants contain TypeScript 'number' types with precision limit of 2^53-1.\n");
        output.push_str(
            " * Large values (e.g., Solana lamports) may lose precision during serialization.\n",
        );
        output.push_str(" */\n");
    }

    // Generate discriminated union type with optional generic parameters
    let type_name_with_generics = if enum_def.generic_params.is_empty() {
        enum_def.name.clone()
    } else {
        format!("{}<{}>", enum_def.name, enum_def.generic_params.join(", "))
    };
    output.push_str(&format!("export type {} =\n", type_name_with_generics));

    for variant in &enum_def.variants {
        let prefix = "  | ";

        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("{}{{ kind: '{}' }}\n", prefix, name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                output.push_str(&format!("{}{{ kind: '{}'", prefix, name));
                for (idx, type_info) in types.iter().enumerate() {
                    let ts_type = map_type_to_typescript(type_info);
                    output.push_str(&format!("; field{}: {}", idx, ts_type));
                }
                output.push_str(" }\n");
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str(&format!("{}{{ kind: '{}'", prefix, name));
                for field in fields {
                    let ts_type = map_type_to_typescript(&field.type_info);
                    output.push_str(&format!("; {}: {}", field.name, ts_type));
                }
                output.push_str(" }\n");
            }
        }
    }

    output.push_str(";\n");

    output
}

/// Generate Borsh schema for enum serialization
fn generate_enum_borsh_schema(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "export const {}Schema = borsh.rustEnum([\n",
        enum_def.name
    ));

    // Generate Borsh variant definitions
    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("  borsh.unit('{}'),\n", name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                output.push_str("  borsh.tuple([\n");
                for type_info in types {
                    let borsh_type = map_type_to_borsh(type_info);
                    output.push_str(&format!("    {},\n", borsh_type));
                }
                output.push_str(&format!("  ], '{}'),\n", name));
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str("  borsh.struct([\n");
                for field in fields {
                    let borsh_type = map_type_to_borsh(&field.type_info);
                    output.push_str(&format!("    {}('{}'),\n", borsh_type, field.name));
                }
                output.push_str(&format!("  ], '{}'),\n", name));
            }
        }
    }

    output.push_str("]);\n");

    output
}

/// Collect required imports based on enum definition
fn collect_enum_imports(enum_def: &EnumDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check variant types for imports
    let mut needs_publickey = false;
    let needs_borsh = enum_def.metadata.solana;

    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { .. } => {}
            EnumVariantDefinition::Tuple { types, .. } => {
                for type_info in types {
                    collect_imports_from_type(type_info, &mut needs_publickey);
                }
            }
            EnumVariantDefinition::Struct { fields, .. } => {
                for field in fields {
                    collect_imports_from_type(&field.type_info, &mut needs_publickey);
                }
            }
        }
    }

    if needs_publickey {
        imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
    }

    if needs_borsh {
        imports.insert("import * as borsh from '@coral-xyz/borsh'".to_string());
    }

    imports
}

/// Collect required imports based on struct definition
fn collect_struct_imports(struct_def: &StructDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check field types for imports
    let mut needs_publickey = false;
    let needs_borsh = struct_def.metadata.solana;

    for field in &struct_def.fields {
        collect_imports_from_type(&field.type_info, &mut needs_publickey);
    }

    if needs_publickey {
        imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
    }

    if needs_borsh {
        imports.insert("import * as borsh from '@coral-xyz/borsh'".to_string());
    }

    imports
}

/// Recursively check if type needs specific imports
fn collect_imports_from_type(type_info: &TypeInfo, needs_publickey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_publickey = true;
            }
        }
        TypeInfo::Generic(_) => {
            // Generic parameters don't require imports
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::FixedArray { element, .. } => {
            collect_imports_from_type(element, needs_publickey);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are in the same module
        }
    }
}

/// Map IR type to TypeScript type
fn map_type_to_typescript(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            match type_name.as_str() {
                // Integer types → number (except u128/i128)
                "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => "number".to_string(),
                "u128" | "i128" => "bigint".to_string(),

                // Floating point
                "f32" | "f64" => "number".to_string(),

                // Boolean
                "bool" => "boolean".to_string(),

                // String
                "String" => "string".to_string(),

                // Solana types
                "Pubkey" | "PublicKey" => "PublicKey".to_string(),
                "Signature" => "string".to_string(),
                "Keypair" => "Keypair".to_string(),

                // Unknown - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{}[]", inner_type)
        }
        TypeInfo::FixedArray { element, .. } => {
            // Fixed arrays also become T[] in TypeScript (size enforced at runtime via Borsh)
            let element_type = map_type_to_typescript(element);
            format!("{}[]", element_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{} | undefined", inner_type)
        }
        TypeInfo::Generic(param_name) => {
            // Generic type parameter - output as-is
            param_name.clone()
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

/// Map IR type to Borsh type
fn map_type_to_borsh(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            "u8" => "borsh.u8".to_string(),
            "u16" => "borsh.u16".to_string(),
            "u32" => "borsh.u32".to_string(),
            "u64" => "borsh.u64".to_string(),
            "u128" => "borsh.u128".to_string(),
            "i8" => "borsh.i8".to_string(),
            "i16" => "borsh.i16".to_string(),
            "i32" => "borsh.i32".to_string(),
            "i64" => "borsh.i64".to_string(),
            "i128" => "borsh.i128".to_string(),
            "f32" => "borsh.f32".to_string(),
            "f64" => "borsh.f64".to_string(),
            "bool" => "borsh.bool".to_string(),
            "String" => "borsh.string".to_string(),
            "Pubkey" | "PublicKey" => "borsh.publicKey".to_string(),
            _ => format!("borsh.{}", type_name.to_lowercase()),
        },
        TypeInfo::Array(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.vec({})", inner_borsh)
        }
        TypeInfo::FixedArray { element, size } => {
            // Fixed-size arrays use borsh.array(element, size) - no length prefix!
            let element_borsh = map_type_to_borsh(element);
            format!("borsh.array({}, {})", element_borsh, size)
        }
        TypeInfo::Option(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.option({})", inner_borsh)
        }
        TypeInfo::Generic(param_name) => {
            // Generic parameters cannot be serialized directly with Borsh
            // They need concrete types at instantiation time
            format!(
                "/* Generic parameter '{}' - Borsh schema needed at concrete type level */",
                param_name
            )
        }
        TypeInfo::UserDefined(type_name) => {
            // User-defined types need their schema
            format!("{}Schema", type_name)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{
        EnumDefinition, EnumVariantDefinition, FieldDefinition, Metadata, StructDefinition,
        TypeDefinition, TypeInfo, Visibility,
    };

    #[test]
    fn generates_simple_interface() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "User".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export interface User"));
        assert!(code.contains("id: number"));
        assert!(code.contains("name: string"));
    }

    #[test]
    fn generates_solana_interface_with_borsh() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export interface UserAccount"));
        assert!(code.contains("wallet: PublicKey"));
        assert!(code.contains("balance: number"));
        assert!(code.contains("export const UserAccountSchema = borsh.struct"));
        assert!(code.contains("borsh.publicKey('wallet')"));
        assert!(code.contains("borsh.u64('balance')"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Profile".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("email?: string | undefined"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Team".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("members: number[]"));
        assert!(code.contains("borsh.vec(borsh.u64)('members')"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "User".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
                visibility: Visibility::Public,

                module_path: Vec::new(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "Post".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
                visibility: Visibility::Public,

                module_path: Vec::new(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("export interface User"));
        assert!(code.contains("export interface Post"));
    }

    #[test]
    fn maps_bigint_types() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "BigNumbers".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "big_unsigned".to_string(),
                    type_info: TypeInfo::Primitive("u128".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "big_signed".to_string(),
                    type_info: TypeInfo::Primitive("i128".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("big_unsigned: bigint"));
        assert!(code.contains("big_signed: bigint"));
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Finished".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameState ="));
        assert!(code.contains("{ kind: 'Active' }"));
        assert!(code.contains("{ kind: 'Paused' }"));
        assert!(code.contains("{ kind: 'Finished' }"));
        assert!(code.contains("export const GameStateSchema = borsh.rustEnum"));
        assert!(code.contains("borsh.unit('Active')"));
        assert!(code.contains("borsh.unit('Paused')"));
        assert!(code.contains("borsh.unit('Finished')"));
    }

    #[test]
    fn generates_tuple_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameEvent".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Tuple {
                    name: "PlayerJoined".to_string(),
                    types: vec![TypeInfo::Primitive("Pubkey".to_string())],
                },
                EnumVariantDefinition::Tuple {
                    name: "ScoreUpdated".to_string(),
                    types: vec![
                        TypeInfo::Primitive("Pubkey".to_string()),
                        TypeInfo::Primitive("u64".to_string()),
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameEvent ="));
        assert!(code.contains("{ kind: 'PlayerJoined'; field0: PublicKey }"));
        assert!(code.contains("{ kind: 'ScoreUpdated'; field0: PublicKey; field1: number }"));
        assert!(code.contains("borsh.tuple(["));
        assert!(code.contains("borsh.publicKey"));
        assert!(code.contains("borsh.u64"));
    }

    #[test]
    fn generates_struct_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameInstruction".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Struct {
                    name: "Initialize".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "authority".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                        FieldDefinition {
                            name: "max_players".to_string(),
                            type_info: TypeInfo::Primitive("u32".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                    ],
                },
                EnumVariantDefinition::Struct {
                    name: "UpdateScore".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "player".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                        FieldDefinition {
                            name: "new_score".to_string(),
                            type_info: TypeInfo::Primitive("u64".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameInstruction ="));
        assert!(code.contains("{ kind: 'Initialize'; authority: PublicKey; max_players: number }"));
        assert!(code.contains("{ kind: 'UpdateScore'; player: PublicKey; new_score: number }"));
        assert!(code.contains("borsh.struct(["));
        assert!(code.contains("borsh.publicKey('authority')"));
        assert!(code.contains("borsh.u32('max_players')"));
        assert!(code.contains("borsh.publicKey('player')"));
        assert!(code.contains("borsh.u64('new_score')"));
    }

    #[test]
    fn generates_partial_eq_derive_helper() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Player".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: false,
                attributes: vec![],
                version: None,
                custom_derives: vec!["PartialEq".to_string()],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export function playerEquals(a: Player, b: Player): boolean"));
        assert!(code.contains("a.id === b.id"));
        assert!(code.contains("a.name === b.name"));
    }

    #[test]
    fn generates_hash_derive_helper() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Token".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "mint".to_string(),
                type_info: TypeInfo::Primitive("PublicKey".to_string()),
                optional: false,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: false,
                attributes: vec![],
                version: None,
                custom_derives: vec!["Hash".to_string()],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export function tokenHashCode(obj: Token): number"));
        assert!(code.contains("let hash = 0"));
        assert!(code.contains("JSON.stringify(obj)"));
    }

    #[test]
    fn generates_default_derive_helper() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Config".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "count".to_string(),
                    type_info: TypeInfo::Primitive("u32".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "enabled".to_string(),
                    type_info: TypeInfo::Primitive("bool".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "label".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: false,
                attributes: vec![],
                version: None,
                custom_derives: vec!["Default".to_string()],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export function configDefault(): Config"));
        assert!(code.contains("count: 0"));
        assert!(code.contains("enabled: false"));
        assert!(code.contains("label: \"\""));
    }

    #[test]
    fn generates_ord_derive_helper() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Score".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "points".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "rank".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: false,
                attributes: vec![],
                version: None,
                custom_derives: vec!["Ord".to_string()],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export function scoreCompare(a: Score, b: Score): number"));
        assert!(code.contains("let cmp: number"));
        assert!(code.contains("a.rank.localeCompare(b.rank)"));
    }

    #[test]
    fn generates_multiple_derive_helpers() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Item".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "value".to_string(),
                type_info: TypeInfo::Primitive("u32".to_string()),
                optional: false,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: false,
                attributes: vec![],
                version: None,
                custom_derives: vec![
                    "PartialEq".to_string(),
                    "Hash".to_string(),
                    "Default".to_string(),
                    "Ord".to_string(),
                ],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        // All four helpers should be generated
        assert!(code.contains("export function itemEquals"));
        assert!(code.contains("export function itemHashCode"));
        assert!(code.contains("export function itemDefault"));
        assert!(code.contains("export function itemCompare"));
    }
}
