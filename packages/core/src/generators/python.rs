// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Python Code Generator
//!
//! Generates Python dataclasses and Borsh schemas from IR for client-side Solana
//! integration with guaranteed serialization compatibility.
//!
//! ## Overview
//!
//! This generator produces type-safe Python code for Solana dApp backends with:
//!
//! - **Python Dataclasses** - Type-safe data structures with type hints
//! - **Borsh Serialization** - Compatible with borsh-construct library
//! - **Enum Support** - Python Enums with dataclass variants
//! - **Solana Integration** - Automatic imports for `solders` types
//!
//! ## Type Mapping
//!
//! IR types are mapped to Python types:
//!
//! | IR Type | Python Type | Borsh Schema | Notes |
//! |---------|-------------|--------------|-------|
//! | `u8`, `u16`, `u32`, `u64` | `int` | `U8`, `U16`, etc. | Python has arbitrary precision |
//! | `u128`, `i128` | `int` | `U128`, `I128` | Native big int support |
//! | `String` | `str` | `String` | UTF-8 strings |
//! | `bool` | `bool` | `Bool` | - |
//! | `PublicKey` | `Pubkey` | `Bytes(32)` | From `solders.pubkey` |
//! | `[T]` | `list[T]` | `Vec(...)` | Dynamic arrays |
//! | `Option<T>` | `T \| None` | `Option(...)` | Optional fields |
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::python};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct UserAccount {
//!         wallet: PublicKey,
//!         balance: u64,
//!         items: [PublicKey],
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let py_code = python::generate_module(&ir);
//!
//! // Generated Python includes dataclass + Borsh schema
//! assert!(py_code.contains("@dataclass"));
//! assert!(py_code.contains("class UserAccount"));
//! assert!(py_code.contains("wallet: Pubkey"));
//! assert!(py_code.contains("balance: int"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeAliasDefinition, TypeDefinition,
    TypeInfo,
};
use std::collections::HashSet;

/// Generate Python code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
        TypeDefinition::TypeAlias(alias_def) => generate_type_alias(alias_def),
    }
}

/// Generate Python code from a type alias definition
fn generate_type_alias(alias_def: &TypeAliasDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let mut needs_pubkey = false;
    collect_imports_from_type(&alias_def.target, &mut needs_pubkey);

    output.push_str("from typing import TypeAlias\n");
    if needs_pubkey {
        output.push_str("from solders.pubkey import Pubkey\n");
    }
    output.push('\n');

    // Generate the type alias
    let py_type = map_type_to_python(&alias_def.target);
    output.push_str(&format!("{}: TypeAlias = {}\n", alias_def.name, py_type));

    output
}

/// Generate Python code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_struct_imports(struct_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{}\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = \"{}\"\n\n",
            struct_def.name.to_uppercase(),
            version
        ));
    }

    // Generate dataclass
    output.push_str(&generate_struct_dataclass(struct_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if struct_def.metadata.solana {
        output.push_str(&generate_struct_borsh_schema(struct_def));
    }

    output
}

/// Generate Python code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("# Auto-generated by LUMOS\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_enum_imports(enum_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{}\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = \"{}\"\n\n",
            enum_def.name.to_uppercase(),
            version
        ));
    }

    // Generate enum type
    output.push_str(&generate_enum_class(enum_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if enum_def.metadata.solana {
        output.push_str(&generate_enum_borsh_schema(enum_def));
    }

    output
}

/// Estimate output size for string capacity pre-allocation
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 300;
    const STRUCT_BASE: usize = 200;
    const FIELD_SIZE: usize = 80;
    const ENUM_BASE: usize = 180;
    const VARIANT_SIZE: usize = 70;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
            TypeDefinition::TypeAlias(_) => 120,
        };
    }

    total
}

/// Generate Python code for a complete module with multiple type definitions.
///
/// This is the primary function for generating Python code from IR.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete Python source code as a `String`, ready to write to a `.py` file.
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str("# Auto-generated by LUMOS\n");
    output.push_str("# DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect all imports needed
    let mut all_imports = HashSet::new();
    for type_def in type_defs {
        match type_def {
            TypeDefinition::Struct(s) => {
                let imports = collect_struct_imports(s);
                all_imports.extend(imports);
            }
            TypeDefinition::Enum(e) => {
                let imports = collect_enum_imports(e);
                all_imports.extend(imports);
            }
            TypeDefinition::TypeAlias(a) => {
                all_imports.insert("from typing import TypeAlias".to_string());
                let mut needs_pubkey = false;
                collect_imports_from_type(&a.target, &mut needs_pubkey);
                if needs_pubkey {
                    all_imports.insert("from solders.pubkey import Pubkey".to_string());
                }
            }
        }
    }

    // Write imports (sorted for deterministic output)
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("{}\n", import));
        }
        output.push('\n');
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                // Generate version constant if present
                if let Some(version) = &s.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = \"{}\"\n\n",
                        s.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_struct_dataclass(s));

                // Add Borsh schema for Solana types
                if s.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_struct_borsh_schema(s));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
            TypeDefinition::Enum(e) => {
                // Generate version constant if present
                if let Some(version) = &e.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = \"{}\"\n\n",
                        e.name.to_uppercase(),
                        version
                    ));
                }

                output.push_str(&generate_enum_class(e));

                // Add Borsh schema for Solana types
                if e.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_enum_borsh_schema(e));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
            TypeDefinition::TypeAlias(a) => {
                let py_type = map_type_to_python(&a.target);
                output.push_str(&format!("{}: TypeAlias = {}\n", a.name, py_type));
            }
        }
    }

    output
}

/// Generate Python dataclass for struct
fn generate_struct_dataclass(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    output.push_str("@dataclass\n");
    output.push_str(&format!("class {}:\n", struct_def.name));

    if struct_def.fields.is_empty() {
        output.push_str("    pass\n");
    } else {
        // Add docstring if we have deprecation warnings
        let deprecated_fields: Vec<_> = struct_def
            .fields
            .iter()
            .filter(|f| f.deprecated.is_some())
            .collect();

        if !deprecated_fields.is_empty() {
            output.push_str("    \"\"\"\n");
            output.push_str("    Deprecated fields:\n");
            for field in &deprecated_fields {
                if let Some(msg) = &field.deprecated {
                    output.push_str(&format!("    - {}: {}\n", field.name, msg));
                } else {
                    output.push_str(&format!("    - {}: deprecated\n", field.name));
                }
            }
            output.push_str("    \"\"\"\n");
        }

        // Generate fields
        for field in &struct_def.fields {
            let py_type = map_type_to_python(&field.type_info);
            // Avoid double "| None" when field is optional AND type is already Option
            let type_annotation = if field.optional && !matches!(&field.type_info, TypeInfo::Option(_)) {
                format!("{} | None", py_type)
            } else {
                py_type
            };

            output.push_str(&format!("    {}: {}\n", field.name, type_annotation));
        }
    }

    output
}

/// Generate Borsh schema for struct serialization
fn generate_struct_borsh_schema(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "{}_SCHEMA = CStruct(\n",
        struct_def.name.to_uppercase()
    ));

    for field in &struct_def.fields {
        let borsh_type = map_type_to_borsh(&field.type_info);
        output.push_str(&format!("    \"{}\" / {},\n", field.name, borsh_type));
    }

    output.push_str(")\n");

    output
}

/// Generate Python enum class
fn generate_enum_class(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Check if all variants are unit variants (simple IntEnum)
    if enum_def.is_unit_only() {
        output.push_str(&format!("class {}(IntEnum):\n", enum_def.name));
        for (idx, variant) in enum_def.variants.iter().enumerate() {
            if let EnumVariantDefinition::Unit { name } = variant {
                output.push_str(&format!("    {} = {}\n", name, idx));
            }
        }
    } else {
        // Complex enum with variants - use tagged union pattern
        output.push_str("# Variant types\n");

        // Generate variant dataclasses
        for variant in &enum_def.variants {
            match variant {
                EnumVariantDefinition::Unit { name } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    output.push_str("    pass\n\n");
                }
                EnumVariantDefinition::Tuple { name, types } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    for (idx, type_info) in types.iter().enumerate() {
                        let py_type = map_type_to_python(type_info);
                        output.push_str(&format!("    field{}: {}\n", idx, py_type));
                    }
                    output.push('\n');
                }
                EnumVariantDefinition::Struct { name, fields } => {
                    output.push_str("@dataclass\n");
                    output.push_str(&format!("class {}{}:\n", enum_def.name, name));
                    if fields.is_empty() {
                        output.push_str("    pass\n\n");
                    } else {
                        for field in fields {
                            let py_type = map_type_to_python(&field.type_info);
                            output.push_str(&format!("    {}: {}\n", field.name, py_type));
                        }
                        output.push('\n');
                    }
                }
            }
        }

        // Generate union type alias
        let variant_names: Vec<String> = enum_def
            .variants
            .iter()
            .map(|v| format!("{}{}", enum_def.name, v.name()))
            .collect();
        output.push_str(&format!(
            "{} = {}\n",
            enum_def.name,
            variant_names.join(" | ")
        ));
    }

    output
}

/// Generate Borsh schema for enum serialization
fn generate_enum_borsh_schema(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    if enum_def.is_unit_only() {
        // Simple enum - just use U8 for discriminant
        output.push_str(&format!(
            "{}_SCHEMA = U8  # Enum discriminant\n",
            enum_def.name.to_uppercase()
        ));
    } else {
        // Complex enum with variants
        output.push_str(&format!(
            "{}_SCHEMA = Enum(\n",
            enum_def.name.to_uppercase()
        ));

        for variant in &enum_def.variants {
            match variant {
                EnumVariantDefinition::Unit { name } => {
                    output.push_str(&format!("    \"{}\" / Pass,\n", name));
                }
                EnumVariantDefinition::Tuple { name, types } => {
                    if types.len() == 1 {
                        let borsh_type = map_type_to_borsh(&types[0]);
                        output.push_str(&format!("    \"{}\" / {},\n", name, borsh_type));
                    } else {
                        output.push_str(&format!("    \"{}\" / CStruct(\n", name));
                        for (idx, type_info) in types.iter().enumerate() {
                            let borsh_type = map_type_to_borsh(type_info);
                            output.push_str(&format!("        \"field{}\" / {},\n", idx, borsh_type));
                        }
                        output.push_str("    ),\n");
                    }
                }
                EnumVariantDefinition::Struct { name, fields } => {
                    output.push_str(&format!("    \"{}\" / CStruct(\n", name));
                    for field in fields {
                        let borsh_type = map_type_to_borsh(&field.type_info);
                        output.push_str(&format!(
                            "        \"{}\" / {},\n",
                            field.name, borsh_type
                        ));
                    }
                    output.push_str("    ),\n");
                }
            }
        }

        output.push_str(")\n");
    }

    output
}

/// Collect required imports based on struct definition
fn collect_struct_imports(struct_def: &StructDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Always need dataclass
    imports.insert("from dataclasses import dataclass".to_string());

    // Check field types for imports
    let mut needs_pubkey = false;
    let needs_borsh = struct_def.metadata.solana;

    for field in &struct_def.fields {
        collect_imports_from_type(&field.type_info, &mut needs_pubkey);
    }

    if needs_pubkey {
        imports.insert("from solders.pubkey import Pubkey".to_string());
    }

    if needs_borsh {
        imports.insert("from borsh_construct import Bytes, CStruct, U8, U16, U32, U64, U128, I8, I16, I32, I64, I128, Bool, String, Vec, Option".to_string());
    }

    imports
}

/// Collect required imports based on enum definition
fn collect_enum_imports(enum_def: &EnumDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check variant types
    let mut needs_pubkey = false;
    let needs_borsh = enum_def.metadata.solana;

    if enum_def.is_unit_only() {
        imports.insert("from enum import IntEnum".to_string());
    } else {
        imports.insert("from dataclasses import dataclass".to_string());

        for variant in &enum_def.variants {
            match variant {
                EnumVariantDefinition::Unit { .. } => {}
                EnumVariantDefinition::Tuple { types, .. } => {
                    for type_info in types {
                        collect_imports_from_type(type_info, &mut needs_pubkey);
                    }
                }
                EnumVariantDefinition::Struct { fields, .. } => {
                    for field in fields {
                        collect_imports_from_type(&field.type_info, &mut needs_pubkey);
                    }
                }
            }
        }
    }

    if needs_pubkey {
        imports.insert("from solders.pubkey import Pubkey".to_string());
    }

    if needs_borsh {
        if enum_def.is_unit_only() {
            imports.insert("from borsh_construct import U8".to_string());
        } else {
            imports.insert("from borsh_construct import CStruct, Enum, Pass, U8, U16, U32, U64, U128, I8, I16, I32, I64, I128, Bool, String, Vec, Option, Bytes".to_string());
        }
    }

    imports
}

/// Recursively check if type needs specific imports
fn collect_imports_from_type(type_info: &TypeInfo, needs_pubkey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_pubkey = true;
            }
        }
        TypeInfo::Generic(_) => {}
        TypeInfo::Array(inner) | TypeInfo::FixedArray { element: inner, .. } => {
            collect_imports_from_type(inner, needs_pubkey);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, needs_pubkey);
        }
        TypeInfo::UserDefined(_) => {}
    }
}

/// Map IR type to Python type
fn map_type_to_python(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            match type_name.as_str() {
                // All integer types map to int (Python handles arbitrary precision)
                "u8" | "u16" | "u32" | "u64" | "u128" | "i8" | "i16" | "i32" | "i64" | "i128" => {
                    "int".to_string()
                }

                // Floating point
                "f32" | "f64" => "float".to_string(),

                // Boolean
                "bool" => "bool".to_string(),

                // String
                "String" => "str".to_string(),

                // Solana types
                "Pubkey" | "PublicKey" => "Pubkey".to_string(),
                "Signature" => "str".to_string(),

                // Unknown - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) | TypeInfo::FixedArray { element: inner, .. } => {
            let inner_type = map_type_to_python(inner);
            format!("list[{}]", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_python(inner);
            format!("{} | None", inner_type)
        }
        TypeInfo::Generic(param_name) => param_name.clone(),
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

/// Map IR type to Borsh schema type (borsh-construct syntax)
fn map_type_to_borsh(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            "u8" => "U8".to_string(),
            "u16" => "U16".to_string(),
            "u32" => "U32".to_string(),
            "u64" => "U64".to_string(),
            "u128" => "U128".to_string(),
            "i8" => "I8".to_string(),
            "i16" => "I16".to_string(),
            "i32" => "I32".to_string(),
            "i64" => "I64".to_string(),
            "i128" => "I128".to_string(),
            "f32" => "F32".to_string(),
            "f64" => "F64".to_string(),
            "bool" => "Bool".to_string(),
            "String" => "String".to_string(),
            "Pubkey" | "PublicKey" => "Bytes(32)".to_string(),
            _ => format!("/* Unknown: {} */", type_name),
        },
        TypeInfo::Array(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("Vec({})", inner_borsh)
        }
        TypeInfo::FixedArray { element, size } => {
            let element_borsh = map_type_to_borsh(element);
            format!("{}[{}]", element_borsh, size)
        }
        TypeInfo::Option(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("Option({})", inner_borsh)
        }
        TypeInfo::Generic(param_name) => {
            format!("/* Generic: {} */", param_name)
        }
        TypeInfo::UserDefined(type_name) => {
            format!("{}_SCHEMA", type_name.to_uppercase())
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, StructDefinition, TypeDefinition, Visibility};

    #[test]
    fn generates_simple_dataclass() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "User".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("@dataclass"));
        assert!(code.contains("class User:"));
        assert!(code.contains("id: int"));
        assert!(code.contains("name: str"));
    }

    #[test]
    fn generates_solana_dataclass_with_borsh() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from solders.pubkey import Pubkey"));
        assert!(code.contains("from borsh_construct import"));
        assert!(code.contains("@dataclass"));
        assert!(code.contains("class UserAccount:"));
        assert!(code.contains("wallet: Pubkey"));
        assert!(code.contains("balance: int"));
        assert!(code.contains("USERACCOUNT_SCHEMA = CStruct("));
        assert!(code.contains("\"wallet\" / Bytes(32)"));
        assert!(code.contains("\"balance\" / U64"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Profile".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        // Should only have single "| None" even when field is optional and type is Option
        assert!(code.contains("email: str | None"));
        assert!(!code.contains("None | None")); // No double None
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Team".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("members: list[int]"));
        assert!(code.contains("\"members\" / Vec(U64)"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "User".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "Post".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("class User:"));
        assert!(code.contains("class Post:"));
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Finished".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from enum import IntEnum"));
        assert!(code.contains("class GameState(IntEnum):"));
        assert!(code.contains("Active = 0"));
        assert!(code.contains("Paused = 1"));
        assert!(code.contains("Finished = 2"));
        assert!(code.contains("GAMESTATE_SCHEMA = U8"));
    }

    #[test]
    fn generates_complex_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameEvent".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Started".to_string(),
                },
                EnumVariantDefinition::Tuple {
                    name: "PlayerJoined".to_string(),
                    types: vec![TypeInfo::Primitive("Pubkey".to_string())],
                },
                EnumVariantDefinition::Struct {
                    name: "ScoreUpdate".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "player".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                        FieldDefinition {
                            name: "score".to_string(),
                            type_info: TypeInfo::Primitive("u64".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("from solders.pubkey import Pubkey"));
        assert!(code.contains("class GameEventStarted:"));
        assert!(code.contains("class GameEventPlayerJoined:"));
        assert!(code.contains("field0: Pubkey"));
        assert!(code.contains("class GameEventScoreUpdate:"));
        assert!(code.contains("player: Pubkey"));
        assert!(code.contains("score: int"));
        assert!(code.contains("GameEvent = GameEventStarted | GameEventPlayerJoined | GameEventScoreUpdate"));
        assert!(code.contains("GAMEEVENT_SCHEMA = Enum("));
    }

    #[test]
    fn maps_all_primitive_types() {
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("u8".to_string())), "int");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("u64".to_string())), "int");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("u128".to_string())), "int");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("i64".to_string())), "int");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("f64".to_string())), "float");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("bool".to_string())), "bool");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("String".to_string())), "str");
        assert_eq!(map_type_to_python(&TypeInfo::Primitive("PublicKey".to_string())), "Pubkey");
    }

    #[test]
    fn maps_borsh_types() {
        assert_eq!(map_type_to_borsh(&TypeInfo::Primitive("u8".to_string())), "U8");
        assert_eq!(map_type_to_borsh(&TypeInfo::Primitive("u64".to_string())), "U64");
        assert_eq!(map_type_to_borsh(&TypeInfo::Primitive("String".to_string())), "String");
        assert_eq!(map_type_to_borsh(&TypeInfo::Primitive("PublicKey".to_string())), "Bytes(32)");
        assert_eq!(
            map_type_to_borsh(&TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string())))),
            "Vec(U64)"
        );
        assert_eq!(
            map_type_to_borsh(&TypeInfo::Option(Box::new(TypeInfo::Primitive("u64".to_string())))),
            "Option(U64)"
        );
    }

    #[test]
    fn handles_deprecated_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "old_field".to_string(),
                    type_info: TypeInfo::Primitive("u32".to_string()),
                    optional: false,
                    deprecated: Some("Use new_field instead".to_string()),
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("Deprecated fields:"));
        assert!(code.contains("old_field: Use new_field instead"));
    }
}
