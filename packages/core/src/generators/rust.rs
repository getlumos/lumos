// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Rust Code Generator
//!
//! Generates production-ready Rust code from IR for Solana programs with intelligent
//! Anchor and Borsh integration.
//!
//! ## Overview
//!
//! This generator produces idiomatic Rust code suitable for Solana blockchain development,
//! with context-aware support for:
//!
//! - **Anchor Framework** - Automatically uses `anchor_lang::prelude::*` when needed
//! - **Borsh Serialization** - Pure Borsh derives for non-Anchor structs
//! - **Smart Imports** - Detects required dependencies (Pubkey, Anchor, Borsh)
//! - **Context-Aware Derives** - No conflicting derives for `#[account]` structs
//!
//! ## Context-Aware Generation
//!
//! The generator intelligently adapts based on type attributes:
//!
//! | Type | Imports | Derives | Notes |
//! |------|---------|---------|-------|
//! | `#[account]` struct | `anchor_lang::prelude::*` | None | Anchor provides derives |
//! | Non-account in Anchor module | `anchor_lang::prelude::*` | `AnchorSerialize, AnchorDeserialize` | Module-level Anchor usage |
//! | Pure Borsh struct | `borsh::{BorshSerialize, BorshDeserialize}` | `BorshSerialize, BorshDeserialize` | Standalone Borsh |
//!
//! ## Type Mapping
//!
//! IR types are mapped to Rust types:
//!
//! - `PublicKey` → `Pubkey` (Solana program type)
//! - `Signature` → `String` (base58 representation)
//! - Arrays → `Vec<T>`
//! - `Option<T>` → `Option<T>`
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::rust};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct UserAccount {
//!         wallet: PublicKey,
//!         balance: u64,
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let rust_code = rust::generate_module(&ir);
//!
//! // Generated code uses Anchor imports, no derives (Anchor provides them)
//! assert!(rust_code.contains("use anchor_lang::prelude::*"));
//! assert!(rust_code.contains("#[account]"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeAliasDefinition,
    TypeDefinition, TypeInfo,
};
use std::collections::HashSet;

/// Generate Rust code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
        TypeDefinition::TypeAlias(alias_def) => generate_type_alias(alias_def),
    }
}

/// Generate Rust code from a type alias definition
fn generate_type_alias(alias_def: &TypeAliasDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports for the target type
    let mut needs_publickey = false;
    check_needs_solana_types(&alias_def.target, &mut needs_publickey);

    if needs_publickey {
        output.push_str("use solana_program::pubkey::Pubkey;\n\n");
    }

    // Generate the type alias
    let rust_type = map_type_to_rust(&alias_def.target);
    output.push_str(&format!("pub type {} = {};\n", alias_def.name, rust_type));

    output
}

/// Generate Rust code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Determine if this struct uses Anchor (#[account])
    let use_anchor = struct_def.metadata.solana
        && struct_def
            .metadata
            .attributes
            .contains(&"account".to_string());

    // Collect required imports
    let imports = collect_struct_imports(struct_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "pub const {}_VERSION: &str = \"{}\";\n\n",
            struct_def.name.to_uppercase(),
            version
        ));
    }

    // Generate derives using context-aware function
    let derives = generate_struct_derives_with_context(struct_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if use_anchor {
        output.push_str("#[account]\n");
    }

    // Generate struct definition with optional generic parameters
    let struct_name_with_generics = if struct_def.generic_params.is_empty() {
        struct_def.name.clone()
    } else {
        format!("{}<{}>", struct_def.name, struct_def.generic_params.join(", "))
    };
    output.push_str(&format!("pub struct {} {{\n", struct_name_with_generics));

    // Generate fields
    for field in &struct_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Generate Rust code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Determine if this enum uses Anchor (#[account])
    let use_anchor = enum_def.metadata.solana
        && enum_def
            .metadata
            .attributes
            .contains(&"account".to_string());

    // Collect required imports
    let imports = collect_enum_imports(enum_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push('\n');
    }

    // Generate version constant if version is specified
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "pub const {}_VERSION: &str = \"{}\";\n\n",
            enum_def.name.to_uppercase(),
            version
        ));
    }

    // Generate derives using context-aware function
    let derives = generate_enum_derives_with_context(enum_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if use_anchor {
        output.push_str("#[account]\n");
    }

    // Generate enum definition with optional generic parameters
    let enum_name_with_generics = if enum_def.generic_params.is_empty() {
        enum_def.name.clone()
    } else {
        format!("{}<{}>", enum_def.name, enum_def.generic_params.join(", "))
    };
    output.push_str(&format!("pub enum {} {{\n", enum_name_with_generics));

    // Generate variants
    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("    {},\n", name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                let type_strs: Vec<String> = types.iter().map(map_type_to_rust).collect();
                output.push_str(&format!("    {}({}),\n", name, type_strs.join(", ")));
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str(&format!("    {} {{\n", name));
                for field in fields {
                    let rust_type = map_type_to_rust(&field.type_info);
                    output.push_str(&format!("        {}: {},\n", field.name, rust_type));
                }
                output.push_str("    },\n");
            }
        }
    }

    output.push_str("}\n");

    output
}

/// Generate Rust code for a complete module with multiple type definitions.
///
/// This is the primary function for generating Rust code from IR. It handles
/// module-level import management, context-aware derive generation, and proper
/// formatting of all type definitions.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete Rust source code as a `String`, ready to write to a `.rs` file.
/// Includes:
/// - Auto-generated file header
/// - Optimized imports (Anchor, Borsh, Solana types)
/// - All struct and enum definitions with proper derives
///
/// # Context-Aware Import Management
///
/// The function analyzes ALL types in the module to determine the optimal import strategy:
///
/// - If **any** type uses `#[account]` → use `anchor_lang::prelude::*` for entire module
/// - Otherwise → collect individual Borsh imports
/// - Automatically adds `solana_program::pubkey::Pubkey` when PublicKey types are detected
///
/// This prevents import conflicts in mixed modules (Anchor + non-Anchor structs).
///
/// # Context-Aware Derives
///
/// Derives are generated based on module context:
///
/// - `#[account]` structs: NO derives (Anchor macro provides them)
/// - Non-account structs in Anchor module: `AnchorSerialize, AnchorDeserialize, Debug, Clone`
/// - Pure Borsh structs: `BorshSerialize, BorshDeserialize, Debug, Clone`
///
/// # Example
///
/// ```rust
/// use lumos_core::{parser, transform, generators::rust};
///
/// let source = r#"
///     #[solana]
///     #[account]
///     struct UserAccount {
///         wallet: PublicKey,
///         balance: u64,
///     }
///
///     #[solana]
///     struct UserStats {
///         wins: u32,
///         losses: u32,
///     }
/// "#;
///
/// let ast = parser::parse_lumos_file(source)?;
/// let ir = transform::transform_to_ir(ast)?;
/// let rust_code = rust::generate_module(&ir);
///
/// // Module uses Anchor imports (because UserAccount has #[account])
/// assert!(rust_code.contains("use anchor_lang::prelude::*"));
/// assert!(rust_code.contains("use solana_program::pubkey::Pubkey"));
///
/// // UserAccount: no derives (Anchor provides them)
/// // UserStats: AnchorSerialize/AnchorDeserialize (in Anchor module)
/// assert!(rust_code.contains("#[account]"));
/// assert!(rust_code.contains("#[derive(AnchorSerialize, AnchorDeserialize"));
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
///
/// # Generated Code Structure
///
/// ```rust,ignore
/// // Auto-generated by LUMOS
/// // DO NOT EDIT - Changes will be overwritten
///
/// use anchor_lang::prelude::*;
/// use solana_program::pubkey::Pubkey;
///
/// #[account]
/// pub struct UserAccount {
///     pub wallet: Pubkey,
///     pub balance: u64,
/// }
///
/// #[derive(AnchorSerialize, AnchorDeserialize, Debug, Clone)]
/// pub struct UserStats {
///     pub wins: u32,
///     pub losses: u32,
/// }
/// ```
// Estimate output size for string capacity pre-allocation
//
// Reduces reallocations for large schemas by estimating the final size.
// Conservative estimate to avoid excessive over-allocation.
//
// # Estimation Formula
//
// - Base overhead: ~200 bytes (header, imports)
// - Per struct: ~150 bytes + (fields × 60 bytes)
// - Per enum: ~120 bytes + (variants × 50 bytes)
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 200;
    const STRUCT_BASE: usize = 150;
    const FIELD_SIZE: usize = 60;
    const ENUM_BASE: usize = 120;
    const VARIANT_SIZE: usize = 50;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
            TypeDefinition::TypeAlias(_) => 100, // Type aliases are small (~50-150 chars)
        };
    }

    total
}

pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    // Estimate output size to reduce allocations for large schemas
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Check if ANY struct or enum uses #[account]
    let has_account_attr = type_defs.iter().any(|t| match t {
        TypeDefinition::Struct(s) => {
            s.metadata.solana && s.metadata.attributes.contains(&"account".to_string())
        }
        TypeDefinition::Enum(e) => {
            e.metadata.solana && e.metadata.attributes.contains(&"account".to_string())
        }
        TypeDefinition::TypeAlias(_) => false, // Type aliases don't have attributes
    });

    // Collect all imports needed
    let mut all_imports = HashSet::new();

    // Determine which import style to use
    if has_account_attr {
        // If any struct/enum uses #[account], use Anchor imports for everything
        all_imports.insert("anchor_lang::prelude::*".to_string());
    } else {
        // Otherwise collect individual imports
        for type_def in type_defs {
            match type_def {
                TypeDefinition::Struct(s) => {
                    let imports = collect_struct_imports(s);
                    all_imports.extend(imports);
                }
                TypeDefinition::Enum(e) => {
                    let imports = collect_enum_imports(e);
                    all_imports.extend(imports);
                }
                TypeDefinition::TypeAlias(a) => {
                    // Check if alias target needs imports
                    collect_imports_from_type(&a.target, &mut all_imports);
                }
            }
        }
    }

    // Check for Solana-specific types
    let mut needs_pubkey = false;
    for type_def in type_defs {
        match type_def {
            TypeDefinition::Struct(s) => {
                for field in &s.fields {
                    check_needs_solana_types(&field.type_info, &mut needs_pubkey);
                }
            }
            TypeDefinition::Enum(e) => {
                for variant in &e.variants {
                    match variant {
                        EnumVariantDefinition::Unit { .. } => {}
                        EnumVariantDefinition::Tuple { types, .. } => {
                            for type_info in types {
                                check_needs_solana_types(type_info, &mut needs_pubkey);
                            }
                        }
                        EnumVariantDefinition::Struct { fields, .. } => {
                            for field in fields {
                                check_needs_solana_types(&field.type_info, &mut needs_pubkey);
                            }
                        }
                    }
                }
            }
            TypeDefinition::TypeAlias(a) => {
                // Check if the alias target type needs Solana imports
                check_needs_solana_types(&a.target, &mut needs_pubkey);
            }
        }
    }

    if needs_pubkey {
        all_imports.insert("solana_program::pubkey::Pubkey".to_string());
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push('\n');
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                output.push_str(&generate_struct_with_context(s, has_account_attr));
            }
            TypeDefinition::Enum(e) => {
                output.push_str(&generate_enum_with_context(e, has_account_attr));
            }
            TypeDefinition::TypeAlias(a) => {
                // Generate type alias (header already generated individually)
                let rust_type = map_type_to_rust(&a.target);
                output.push_str(&format!("pub type {} = {};\n", a.name, rust_type));
            }
        }
    }

    output
}

/// Check if type needs Solana-specific imports
fn check_needs_solana_types(type_info: &TypeInfo, needs_pubkey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_pubkey = true;
            }
        }
        TypeInfo::Generic(_) => {
            // Generic parameters don't require imports
        }
        TypeInfo::Array(inner) => {
            check_needs_solana_types(inner, needs_pubkey);
        }
        TypeInfo::FixedArray { element, .. } => {
            check_needs_solana_types(element, needs_pubkey);
        }
        TypeInfo::Option(inner) => {
            check_needs_solana_types(inner, needs_pubkey);
        }
        TypeInfo::UserDefined(_) => {}
    }
}

/// Generate enum with context (e.g., whether module uses Anchor)
fn generate_enum_with_context(enum_def: &EnumDefinition, use_anchor: bool) -> String {
    let mut output = String::new();

    // Generate version constant if present
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "pub const {}_VERSION: &str = \"{}\";\n\n",
            enum_def.name.to_uppercase(),
            version
        ));
    }

    // Generate derives (only if there are any)
    let derives = generate_enum_derives_with_context(enum_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if enum_def.metadata.solana
        && enum_def
            .metadata
            .attributes
            .contains(&"account".to_string())
    {
        output.push_str("#[account]\n");
    }

    // Generate enum definition with optional generic parameters
    let enum_name_with_generics = if enum_def.generic_params.is_empty() {
        enum_def.name.clone()
    } else {
        format!("{}<{}>", enum_def.name, enum_def.generic_params.join(", "))
    };
    output.push_str(&format!("pub enum {} {{\n", enum_name_with_generics));

    // Generate variants
    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("    {},\n", name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                let type_strs: Vec<String> = types.iter().map(map_type_to_rust).collect();
                output.push_str(&format!("    {}({}),\n", name, type_strs.join(", ")));
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str(&format!("    {} {{\n", name));
                for field in fields {
                    let rust_type = map_type_to_rust(&field.type_info);
                    output.push_str(&format!("        {}: {},\n", field.name, rust_type));
                }
                output.push_str("    },\n");
            }
        }
    }

    output.push_str("}\n");

    output
}

/// Generate struct with context (e.g., whether module uses Anchor)
fn generate_struct_with_context(struct_def: &StructDefinition, use_anchor: bool) -> String {
    let mut output = String::new();

    // Generate version constant if present
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "pub const {}_VERSION: &str = \"{}\";\n\n",
            struct_def.name.to_uppercase(),
            version
        ));
    }

    // Generate derives (only if there are any)
    let derives = generate_struct_derives_with_context(struct_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if struct_def.metadata.solana
        && struct_def
            .metadata
            .attributes
            .contains(&"account".to_string())
    {
        output.push_str("#[account]\n");
    }

    // Generate struct definition with optional generic parameters
    let struct_name_with_generics = if struct_def.generic_params.is_empty() {
        struct_def.name.clone()
    } else {
        format!("{}<{}>", struct_def.name, struct_def.generic_params.join(", "))
    };
    output.push_str(&format!("pub struct {} {{\n", struct_name_with_generics));

    // Generate fields
    for field in &struct_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Merge auto-generated derives with custom derives, removing duplicates
///
/// # Arguments
///
/// * `auto_derives` - Automatically generated derives (BorshSerialize, Debug, Clone, etc.)
/// * `custom_derives` - User-specified custom derives (PartialEq, Eq, Hash, etc.)
///
/// # Returns
///
/// Merged and deduplicated list of derives, with auto-generated derives first
fn merge_derives(auto_derives: Vec<String>, custom_derives: &[String]) -> Vec<String> {
    use std::collections::HashSet;

    let mut seen = HashSet::new();
    let mut result = Vec::new();

    // Add auto-generated derives first
    for derive in auto_derives {
        if seen.insert(derive.clone()) {
            result.push(derive);
        }
    }

    // Add custom derives (skip duplicates)
    for derive in custom_derives {
        if seen.insert(derive.clone()) {
            result.push(derive.clone());
        }
    }

    result
}

/// Generate derives with context about whether we're using Anchor (for enums)
fn generate_enum_derives_with_context(enum_def: &EnumDefinition, use_anchor: bool) -> Vec<String> {
    let mut auto_derives = Vec::new();

    // If using #[account], no auto derives needed (Anchor provides them)
    // But still add custom derives
    if enum_def.metadata.solana
        && enum_def
            .metadata
            .attributes
            .contains(&"account".to_string())
    {
        return merge_derives(auto_derives, &enum_def.metadata.custom_derives);
    }

    // If it's a Solana type but module uses Anchor, use Anchor derives
    if enum_def.metadata.solana && use_anchor {
        auto_derives.push("AnchorSerialize".to_string());
        auto_derives.push("AnchorDeserialize".to_string());
        auto_derives.push("Debug".to_string());
        auto_derives.push("Clone".to_string());
        return merge_derives(auto_derives, &enum_def.metadata.custom_derives);
    }

    // Otherwise use Borsh derives
    if enum_def.metadata.solana {
        auto_derives.push("BorshSerialize".to_string());
        auto_derives.push("BorshDeserialize".to_string());
    }

    auto_derives.push("Debug".to_string());
    auto_derives.push("Clone".to_string());

    merge_derives(auto_derives, &enum_def.metadata.custom_derives)
}

/// Generate derives with context about whether we're using Anchor
fn generate_struct_derives_with_context(
    struct_def: &StructDefinition,
    use_anchor: bool,
) -> Vec<String> {
    let mut auto_derives = Vec::new();

    // If using #[account], no auto derives needed (Anchor provides them)
    // But still add custom derives
    if struct_def.metadata.solana
        && struct_def
            .metadata
            .attributes
            .contains(&"account".to_string())
    {
        return merge_derives(auto_derives, &struct_def.metadata.custom_derives);
    }

    // If it's a Solana type but module uses Anchor, use Anchor derives
    if struct_def.metadata.solana && use_anchor {
        auto_derives.push("AnchorSerialize".to_string());
        auto_derives.push("AnchorDeserialize".to_string());
        auto_derives.push("Debug".to_string());
        auto_derives.push("Clone".to_string());
        return merge_derives(auto_derives, &struct_def.metadata.custom_derives);
    }

    // Otherwise use Borsh derives
    if struct_def.metadata.solana {
        auto_derives.push("BorshSerialize".to_string());
        auto_derives.push("BorshDeserialize".to_string());
    }

    auto_derives.push("Debug".to_string());
    auto_derives.push("Clone".to_string());

    merge_derives(auto_derives, &struct_def.metadata.custom_derives)
}

/// Collect required imports based on enum definition
fn collect_enum_imports(enum_def: &EnumDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check if we need Borsh or Anchor imports
    if enum_def.metadata.solana {
        // If using #[account], use Anchor imports (includes Borsh)
        if enum_def
            .metadata
            .attributes
            .contains(&"account".to_string())
        {
            imports.insert("anchor_lang::prelude::*".to_string());
        } else {
            // Otherwise use Borsh directly
            imports.insert("borsh::{BorshSerialize, BorshDeserialize}".to_string());
        }
    }

    // Check variant types for Solana-specific imports
    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { .. } => {}
            EnumVariantDefinition::Tuple { types, .. } => {
                for type_info in types {
                    collect_imports_from_type(type_info, &mut imports);
                }
            }
            EnumVariantDefinition::Struct { fields, .. } => {
                for field in fields {
                    collect_imports_from_type(&field.type_info, &mut imports);
                }
            }
        }
    }

    imports
}

/// Collect required imports based on struct definition
fn collect_struct_imports(struct_def: &StructDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check if we need Borsh or Anchor imports
    if struct_def.metadata.solana {
        // If using #[account], use Anchor imports (includes Borsh)
        if struct_def
            .metadata
            .attributes
            .contains(&"account".to_string())
        {
            imports.insert("anchor_lang::prelude::*".to_string());
        } else {
            // Otherwise use Borsh directly
            imports.insert("borsh::{BorshSerialize, BorshDeserialize}".to_string());
        }
    }

    // Check field types for Solana-specific imports
    for field in &struct_def.fields {
        collect_imports_from_type(&field.type_info, &mut imports);
    }

    imports
}

/// Recursively collect imports from a type
fn collect_imports_from_type(type_info: &TypeInfo, imports: &mut HashSet<String>) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle both Pubkey and PublicKey (they map to same Rust type)
            if type_name == "Pubkey" || type_name == "PublicKey" {
                imports.insert("solana_program::pubkey::Pubkey".to_string());
            }
            // Note: Signature is mapped to String in Rust (no special import needed)
        }
        TypeInfo::Generic(_) => {
            // Generic parameters don't require imports
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::FixedArray { element, .. } => {
            collect_imports_from_type(element, imports);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are assumed to be in the same module
        }
    }
}

/// Map IR type to Rust type
fn map_type_to_rust(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle type mapping
            match type_name.as_str() {
                // Already Rust types
                "u8" | "u16" | "u32" | "u64" | "u128" => type_name.clone(),
                "i8" | "i16" | "i32" | "i64" | "i128" => type_name.clone(),
                "f32" | "f64" => type_name.clone(),
                "bool" => "bool".to_string(),
                "String" => "String".to_string(),

                // Solana types
                "Pubkey" => "Pubkey".to_string(),
                "PublicKey" => "Pubkey".to_string(), // Map PublicKey to Pubkey
                "Signature" => "String".to_string(), // Map Signature to String (base58)
                "Keypair" => "Keypair".to_string(),

                // Unknown type - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Generic(param_name) => {
            // Generic type parameter - output as-is
            param_name.clone()
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Vec<{}>", inner_type)
        }
        TypeInfo::FixedArray { element, size } => {
            let element_type = map_type_to_rust(element);
            format!("[{}; {}]", element_type, size)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Option<{}>", inner_type)
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{
        EnumDefinition, EnumVariantDefinition, FieldDefinition, Metadata, StructDefinition,
        TypeDefinition, TypeInfo,
    };

    #[test]
    fn generates_simple_struct() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "User".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                },
            ],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub id: u64"));
        assert!(code.contains("pub name: String"));
        assert!(code.contains("Debug, Clone"));
    }

    #[test]
    fn generates_solana_account() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("Pubkey".to_string()),
                    optional: false,
                    deprecated: None,
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("use anchor_lang::prelude::*"));
        assert!(code.contains("use solana_program::pubkey::Pubkey"));
        assert!(code.contains("#[account]"));
        // Note: #[account] structs don't have derives (Anchor provides them)
        assert!(!code.contains("#[derive"));
        assert!(code.contains("pub wallet: Pubkey"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Profile".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
                deprecated: None,
            }],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("pub email: Option<String>"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Team".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
                deprecated: None,
            }],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("pub members: Vec<u64>"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "User".to_string(),
            generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "Post".to_string(),
            generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub struct Post"));
    }

    #[test]
    fn maps_publickey_to_pubkey() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "key".to_string(),
                type_info: TypeInfo::Primitive("PublicKey".to_string()),
                optional: false,
                deprecated: None,
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("pub key: Pubkey"));
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Finished".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("use borsh::{BorshSerialize, BorshDeserialize}"));
        assert!(code.contains("#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]"));
        assert!(code.contains("pub enum GameState"));
        assert!(code.contains("Active,"));
        assert!(code.contains("Paused,"));
        assert!(code.contains("Finished,"));
    }

    #[test]
    fn generates_tuple_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameEvent".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Tuple {
                    name: "PlayerJoined".to_string(),
                    types: vec![TypeInfo::Primitive("Pubkey".to_string())],
                },
                EnumVariantDefinition::Tuple {
                    name: "ScoreUpdated".to_string(),
                    types: vec![
                        TypeInfo::Primitive("Pubkey".to_string()),
                        TypeInfo::Primitive("u64".to_string()),
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("use borsh::{BorshSerialize, BorshDeserialize}"));
        assert!(code.contains("use solana_program::pubkey::Pubkey"));
        assert!(code.contains("#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]"));
        assert!(code.contains("pub enum GameEvent"));
        assert!(code.contains("PlayerJoined(Pubkey),"));
        assert!(code.contains("ScoreUpdated(Pubkey, u64),"));
    }

    #[test]
    fn generates_struct_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameInstruction".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Struct {
                    name: "Initialize".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "authority".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                            deprecated: None,
                        },
                        FieldDefinition {
                            name: "max_players".to_string(),
                            type_info: TypeInfo::Primitive("u32".to_string()),
                            optional: false,
                            deprecated: None,
                        },
                    ],
                },
                EnumVariantDefinition::Struct {
                    name: "UpdateScore".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "player".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                            deprecated: None,
                        },
                        FieldDefinition {
                            name: "new_score".to_string(),
                            type_info: TypeInfo::Primitive("u64".to_string()),
                            optional: false,
                            deprecated: None,
                        },
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("use borsh::{BorshSerialize, BorshDeserialize}"));
        assert!(code.contains("use solana_program::pubkey::Pubkey"));
        assert!(code.contains("#[derive(BorshSerialize, BorshDeserialize, Debug, Clone)]"));
        assert!(code.contains("pub enum GameInstruction"));
        assert!(code.contains("Initialize {"));
        assert!(code.contains("authority: Pubkey,"));
        assert!(code.contains("max_players: u32,"));
        assert!(code.contains("UpdateScore {"));
        assert!(code.contains("player: Pubkey,"));
        assert!(code.contains("new_score: u64,"));
    }

    #[test]
    fn test_custom_derives_on_struct() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "balance".to_string(),
                type_info: TypeInfo::Primitive("u64".to_string()),
                optional: false,
                deprecated: None,
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![
                    "PartialEq".to_string(),
                    "Eq".to_string(),
                    "Hash".to_string(),
                ],
            },
        });

        let code = generate(&type_def);
        // Should have auto-generated derives + custom derives
        assert!(code.contains(
            "#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq, Eq, Hash)]"
        ));
    }

    #[test]
    fn test_custom_derives_deduplication() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                // User specifies Debug and Clone, which are auto-generated
                custom_derives: vec![
                    "Debug".to_string(),
                    "Clone".to_string(),
                    "PartialEq".to_string(),
                ],
            },
        });

        let code = generate(&type_def);
        // Debug and Clone should appear only once (not duplicated)
        assert!(
            code.contains("#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]")
        );
        // Count occurrences of "Debug" in derives line
        let derives_line = code.lines().find(|line| line.contains("#[derive")).unwrap();
        assert_eq!(derives_line.matches("Debug").count(), 1);
        assert_eq!(derives_line.matches("Clone").count(), 1);
    }

    #[test]
    fn test_custom_derives_on_anchor_account() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            generic_params: vec![],
            fields: vec![],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec!["PartialEq".to_string(), "Eq".to_string()],
            },
        });

        let code = generate(&type_def);
        // Anchor accounts have no auto derives, but custom derives should be added
        assert!(code.contains("#[derive(PartialEq, Eq)]"));
        assert!(code.contains("#[account]"));
    }

    #[test]
    fn test_custom_derives_on_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec!["PartialEq".to_string(), "Eq".to_string()],
            },
        });

        let code = generate(&type_def);
        // Should have auto-generated derives + custom derives
        assert!(code
            .contains("#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq, Eq)]"));
    }

    #[test]
    fn test_end_to_end_custom_derives() {
        use crate::{parser, transform};

        let input = r#"
            #[solana]
            #[derive(PartialEq, Eq, Hash)]
            struct Account {
                balance: u64,
            }
        "#;

        let ast = parser::parse_lumos_file(input).unwrap();
        let ir = transform::transform_to_ir(ast).unwrap();
        let code = generate_module(&ir);

        // Full end-to-end test: parse → transform → generate
        assert!(code.contains(
            "#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq, Eq, Hash)]"
        ));
        assert!(code.contains("pub struct Account"));
        assert!(code.contains("pub balance: u64"));
    }
}
