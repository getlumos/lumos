// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Rust code generator
//!
//! Generates production-ready Rust code from IR for use in Solana programs.

use crate::ir::{TypeDefinition, TypeInfo};
use std::collections::HashSet;

/// Generate Rust code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_imports(type_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push_str("\n");
    }

    // Generate derives
    let derives = generate_derives(type_def);
    output.push_str(&format!("#[derive({})]\n", derives.join(", ")));

    // Add Solana-specific attributes
    if type_def.metadata.solana && type_def.metadata.attributes.contains(&"account".to_string()) {
        output.push_str("#[account]\n");
    }

    // Generate struct definition
    output.push_str(&format!("pub struct {} {{\n", type_def.name));

    // Generate fields
    for field in &type_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Generate Rust code for multiple type definitions
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect all imports needed
    let mut all_imports = HashSet::new();
    for type_def in type_defs {
        let imports = collect_imports(type_def);
        all_imports.extend(imports);
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push_str("\n");
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push_str("\n");
        }
        output.push_str(&generate_struct_only(type_def));
    }

    output
}

/// Generate just the struct definition (without imports/header)
fn generate_struct_only(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    // Generate derives
    let derives = generate_derives(type_def);
    output.push_str(&format!("#[derive({})]\n", derives.join(", ")));

    // Add Solana-specific attributes
    if type_def.metadata.solana && type_def.metadata.attributes.contains(&"account".to_string()) {
        output.push_str("#[account]\n");
    }

    // Generate struct definition
    output.push_str(&format!("pub struct {} {{\n", type_def.name));

    // Generate fields
    for field in &type_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Collect required imports based on type definition
fn collect_imports(type_def: &TypeDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check if we need Borsh imports
    if type_def.metadata.solana {
        imports.insert("borsh::{BorshSerialize, BorshDeserialize}".to_string());
    }

    // Check field types for Solana-specific imports
    for field in &type_def.fields {
        collect_imports_from_type(&field.type_info, &mut imports);
    }

    imports
}

/// Recursively collect imports from a type
fn collect_imports_from_type(type_info: &TypeInfo, imports: &mut HashSet<String>) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle both Pubkey and PublicKey (they map to same Rust type)
            if type_name == "Pubkey" || type_name == "PublicKey" {
                imports.insert("solana_program::pubkey::Pubkey".to_string());
            } else if type_name == "Signature" {
                imports.insert("solana_program::signature::Signature".to_string());
            }
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are assumed to be in the same module
        }
    }
}

/// Generate derive macros based on metadata
fn generate_derives(type_def: &TypeDefinition) -> Vec<String> {
    let mut derives = vec!["Debug".to_string(), "Clone".to_string()];

    // Add Borsh derives for Solana types
    if type_def.metadata.solana {
        derives.insert(0, "BorshDeserialize".to_string());
        derives.insert(0, "BorshSerialize".to_string());
    }

    derives
}

/// Map IR type to Rust type
fn map_type_to_rust(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle type mapping
            match type_name.as_str() {
                // Already Rust types
                "u8" | "u16" | "u32" | "u64" | "u128" => type_name.clone(),
                "i8" | "i16" | "i32" | "i64" | "i128" => type_name.clone(),
                "f32" | "f64" => type_name.clone(),
                "bool" => "bool".to_string(),
                "String" => "String".to_string(),

                // Solana types
                "Pubkey" => "Pubkey".to_string(),
                "PublicKey" => "Pubkey".to_string(), // Map PublicKey to Pubkey
                "Signature" => "Signature".to_string(),
                "Keypair" => "Keypair".to_string(),

                // Unknown type - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Vec<{}>", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Option<{}>", inner_type)
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, TypeDefinition, TypeInfo};

    #[test]
    fn generates_simple_struct() {
        let type_def = TypeDefinition {
            name: "User".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub id: u64"));
        assert!(code.contains("pub name: String"));
        assert!(code.contains("Debug, Clone"));
    }

    #[test]
    fn generates_solana_account() {
        let type_def = TypeDefinition {
            name: "UserAccount".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("Pubkey".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("use borsh::{BorshSerialize, BorshDeserialize}"));
        assert!(code.contains("use solana_program::pubkey::Pubkey"));
        assert!(code.contains("BorshSerialize, BorshDeserialize"));
        assert!(code.contains("#[account]"));
        assert!(code.contains("pub wallet: Pubkey"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition {
            name: "Profile".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "email".to_string(),
                    type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive(
                        "String".to_string(),
                    ))),
                    optional: true,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub email: Option<String>"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition {
            name: "Team".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "members".to_string(),
                    type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub members: Vec<u64>"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition {
                name: "User".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
            TypeDefinition {
                name: "Post".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub struct Post"));
    }

    #[test]
    fn maps_publickey_to_pubkey() {
        let type_def = TypeDefinition {
            name: "Account".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "key".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("pub key: Pubkey"));
    }
}
