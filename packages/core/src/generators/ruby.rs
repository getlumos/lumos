// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Ruby Code Generator
//!
//! Generates Ruby classes and Borsh serialization from IR for backend Solana
//! integration with guaranteed serialization compatibility.
//!
//! ## Overview
//!
//! This generator produces type-safe Ruby code for Solana dApp backends with:
//!
//! - **Ruby Classes** - Type-documented data structures with attr_accessor
//! - **Borsh Serialization** - Compatible with `borsh-rb` gem
//! - **Enum Support** - Ruby modules with constants and Struct-based variants
//! - **Solana Integration** - Byte array handling for public keys
//!
//! ## Type Mapping
//!
//! IR types are mapped to Ruby types:
//!
//! | IR Type | Ruby Type | Notes |
//! |---------|-----------|-------|
//! | `u8`, `u16`, `u32`, `u64` | `Integer` | Ruby integers are arbitrary precision |
//! | `u128`, `i128` | `Integer` | Ruby handles big integers natively |
//! | `String` | `String` | UTF-8 strings |
//! | `bool` | `TrueClass/FalseClass` | Boolean values |
//! | `PublicKey` | `String` | 32-byte hex or base58 string |
//! | `[T]` | `Array<T>` | Dynamic arrays |
//! | `[T; N]` | `Array<T>` | Fixed-size arrays |
//! | `Option<T>` | `T, nil` | Nilable types |
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::ruby};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct UserAccount {
//!         wallet: PublicKey,
//!         balance: u64,
//!         items: [PublicKey],
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let ruby_code = ruby::generate_module(&ir);
//!
//! // Generated Ruby includes class with attr_accessor
//! assert!(ruby_code.contains("class UserAccount"));
//! assert!(ruby_code.contains("attr_accessor :wallet"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeAliasDefinition, TypeDefinition,
    TypeInfo,
};

/// Generate Ruby code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
        TypeDefinition::TypeAlias(alias_def) => generate_type_alias(alias_def),
    }
}

/// Generate Ruby code from a type alias definition
fn generate_type_alias(alias_def: &TypeAliasDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str(&generate_header());

    // Generate the type alias as a constant
    let ruby_type = map_type_to_ruby(&alias_def.target);
    output.push_str(&format!(
        "# Type alias: {} = {}\n",
        alias_def.name, ruby_type
    ));
    output.push_str(&format!("{} = {}\n", alias_def.name, ruby_type));

    output
}

/// Generate Ruby code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str(&generate_header());

    // Add frozen_string_literal pragma for performance
    output.push_str("# frozen_string_literal: true\n\n");

    // Generate version constant if version is specified
    if let Some(version) = &struct_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = '{}'\n\n",
            to_screaming_snake_case(&struct_def.name),
            version
        ));
    }

    // Generate class
    output.push_str(&generate_struct_class(struct_def));

    output
}

/// Generate Ruby code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str(&generate_header());

    // Add frozen_string_literal pragma
    output.push_str("# frozen_string_literal: true\n\n");

    // Generate version constant if version is specified
    if let Some(version) = &enum_def.metadata.version {
        output.push_str(&format!(
            "{}_VERSION = '{}'\n\n",
            to_screaming_snake_case(&enum_def.name),
            version
        ));
    }

    // Generate enum type
    output.push_str(&generate_enum_module(enum_def));

    output
}

/// Generate file header
fn generate_header() -> String {
    "# Auto-generated by LUMOS\n# DO NOT EDIT - Changes will be overwritten\n\n".to_string()
}

/// Estimate output size for string capacity pre-allocation
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 400;
    const STRUCT_BASE: usize = 300;
    const FIELD_SIZE: usize = 120;
    const ENUM_BASE: usize = 350;
    const VARIANT_SIZE: usize = 200;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
            TypeDefinition::TypeAlias(_) => 100,
        };
    }

    total
}

/// Generate Ruby code for a complete module with multiple type definitions.
///
/// This is the primary function for generating Ruby code from IR.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete Ruby source code as a `String`, ready to write to a `.rb` file.
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str(&generate_header());

    // Add frozen_string_literal pragma
    output.push_str("# frozen_string_literal: true\n\n");

    // Add require for borsh if any Solana types
    let needs_borsh = type_defs.iter().any(|td| match td {
        TypeDefinition::Struct(s) => s.metadata.solana,
        TypeDefinition::Enum(e) => e.metadata.solana,
        TypeDefinition::TypeAlias(_) => false,
    });

    if needs_borsh {
        output.push_str("require 'borsh'\n\n");
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                // Generate version constant if present
                if let Some(version) = &s.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = '{}'\n\n",
                        to_screaming_snake_case(&s.name),
                        version
                    ));
                }

                output.push_str(&generate_struct_class(s));
            }
            TypeDefinition::Enum(e) => {
                // Generate version constant if present
                if let Some(version) = &e.metadata.version {
                    output.push_str(&format!(
                        "{}_VERSION = '{}'\n\n",
                        to_screaming_snake_case(&e.name),
                        version
                    ));
                }

                output.push_str(&generate_enum_module(e));
            }
            TypeDefinition::TypeAlias(a) => {
                let ruby_type = map_type_to_ruby(&a.target);
                output.push_str(&format!("# Type alias: {} = {}\n", a.name, ruby_type));
                output.push_str(&format!("{} = {}\n", a.name, ruby_type));
            }
        }
    }

    output
}

/// Generate Ruby class for struct
fn generate_struct_class(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add deprecation comments if any
    let deprecated_fields: Vec<_> = struct_def
        .fields
        .iter()
        .filter(|f| f.deprecated.is_some())
        .collect();

    if !deprecated_fields.is_empty() {
        output.push_str("# Deprecated fields:\n");
        for field in &deprecated_fields {
            if let Some(msg) = &field.deprecated {
                output.push_str(&format!("#   - {}: {}\n", field.name, msg));
            } else {
                output.push_str(&format!("#   - {}: deprecated\n", field.name));
            }
        }
    }

    // Generate class definition
    output.push_str(&format!("class {}\n", struct_def.name));

    if struct_def.fields.is_empty() {
        output.push_str("end\n");
    } else {
        // Generate attr_accessor for all fields
        let field_names: Vec<String> = struct_def
            .fields
            .iter()
            .map(|f| format!(":{}", to_snake_case(&f.name)))
            .collect();
        output.push_str(&format!("  attr_accessor {}\n\n", field_names.join(", ")));

        // Generate YARD documentation for types
        output.push_str("  # @param opts [Hash] Field values\n");
        for field in &struct_def.fields {
            let ruby_type = map_type_to_ruby(&field.type_info);
            let type_doc = if field.optional
                && !matches!(&field.type_info, TypeInfo::Option(_))
            {
                format!("{}, nil", ruby_type)
            } else {
                ruby_type
            };

            // Add deprecation warning in YARD
            if let Some(msg) = &field.deprecated {
                output.push_str(&format!(
                    "  # @deprecated {}\n",
                    msg
                ));
            }
            output.push_str(&format!(
                "  # @option opts [{}] :{}\n",
                type_doc,
                to_snake_case(&field.name)
            ));
        }

        // Generate initialize method
        output.push_str("  def initialize(opts = {})\n");
        for field in &struct_def.fields {
            let field_name = to_snake_case(&field.name);
            output.push_str(&format!(
                "    @{} = opts[:{}]\n",
                field_name, field_name
            ));
        }
        output.push_str("  end\n");

        // Generate to_h method for serialization
        output.push_str("\n  # @return [Hash] Field values as hash\n");
        output.push_str("  def to_h\n");
        output.push_str("    {\n");
        for field in &struct_def.fields {
            let field_name = to_snake_case(&field.name);
            output.push_str(&format!("      {}: @{},\n", field_name, field_name));
        }
        output.push_str("    }\n");
        output.push_str("  end\n");

        // Generate Borsh schema if Solana type
        if struct_def.metadata.solana {
            output.push_str("\n  # Borsh schema for serialization\n");
            output.push_str("  SCHEMA = {\n");
            for field in &struct_def.fields {
                let borsh_type = map_type_to_borsh(&field.type_info);
                output.push_str(&format!(
                    "    {} => {},\n",
                    to_snake_case(&field.name),
                    borsh_type
                ));
            }
            output.push_str("  }.freeze\n");
        }

        output.push_str("end\n");
    }

    output
}

/// Generate Ruby module for enum
fn generate_enum_module(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    if enum_def.is_unit_only() {
        // Simple enum - use module with constants
        output.push_str(&format!("module {}\n", enum_def.name));
        for (idx, variant) in enum_def.variants.iter().enumerate() {
            if let EnumVariantDefinition::Unit { name } = variant {
                output.push_str(&format!("  {} = {}\n", to_screaming_snake_case(name), idx));
            }
        }
        output.push('\n');

        // Add helper methods
        output.push_str("  # @param value [Integer] Enum value\n");
        output.push_str("  # @return [String] Enum name\n");
        output.push_str("  def self.name_for(value)\n");
        output.push_str("    case value\n");
        for variant in &enum_def.variants {
            if let EnumVariantDefinition::Unit { name } = variant {
                output.push_str(&format!(
                    "    when {} then '{}'\n",
                    to_screaming_snake_case(name),
                    name
                ));
            }
        }
        output.push_str("    else 'Unknown'\n");
        output.push_str("    end\n");
        output.push_str("  end\n");
        output.push_str("end\n");
    } else {
        // Complex enum with variants - use module with Struct-based variants
        output.push_str(&format!("module {}\n", enum_def.name));

        // Generate discriminant constants
        output.push_str("  # Discriminant values\n");
        for (idx, variant) in enum_def.variants.iter().enumerate() {
            output.push_str(&format!(
                "  {}_DISCRIMINANT = {}\n",
                to_screaming_snake_case(variant.name()),
                idx
            ));
        }
        output.push('\n');

        // Generate variant classes
        for variant in &enum_def.variants {
            match variant {
                EnumVariantDefinition::Unit { name } => {
                    output.push_str(&format!(
                        "  {} = Struct.new(:discriminant) do\n",
                        name
                    ));
                    output.push_str(&format!(
                        "    def initialize\n      super({}_DISCRIMINANT)\n    end\n",
                        to_screaming_snake_case(name)
                    ));
                    output.push_str("  end\n\n");
                }
                EnumVariantDefinition::Tuple { name, types } => {
                    let fields: Vec<String> = (0..types.len())
                        .map(|i| format!(":field{}", i))
                        .collect();
                    output.push_str(&format!(
                        "  {} = Struct.new(:discriminant, {}) do\n",
                        name,
                        fields.join(", ")
                    ));

                    // Add YARD docs
                    for (idx, type_info) in types.iter().enumerate() {
                        let ruby_type = map_type_to_ruby(type_info);
                        output.push_str(&format!("    # @return [{}] field{}\n", ruby_type, idx));
                    }

                    // Initialize with discriminant
                    let init_params: Vec<String> = (0..types.len())
                        .map(|i| format!("field{}", i))
                        .collect();
                    let init_args: Vec<String> = (0..types.len())
                        .map(|i| format!("field{}", i))
                        .collect();
                    output.push_str(&format!(
                        "    def initialize({})\n      super({}_DISCRIMINANT, {})\n    end\n",
                        init_params.join(", "),
                        to_screaming_snake_case(name),
                        init_args.join(", ")
                    ));
                    output.push_str("  end\n\n");
                }
                EnumVariantDefinition::Struct { name, fields } => {
                    let field_symbols: Vec<String> = fields
                        .iter()
                        .map(|f| format!(":{}", to_snake_case(&f.name)))
                        .collect();
                    output.push_str(&format!(
                        "  {} = Struct.new(:discriminant, {}) do\n",
                        name,
                        field_symbols.join(", ")
                    ));

                    // Add YARD docs
                    for field in fields {
                        let ruby_type = map_type_to_ruby(&field.type_info);
                        output.push_str(&format!(
                            "    # @return [{}] {}\n",
                            ruby_type,
                            to_snake_case(&field.name)
                        ));
                    }

                    // Initialize with discriminant
                    let init_params: Vec<String> = fields
                        .iter()
                        .map(|f| to_snake_case(&f.name))
                        .collect();
                    let init_args: Vec<String> = fields
                        .iter()
                        .map(|f| to_snake_case(&f.name))
                        .collect();
                    output.push_str(&format!(
                        "    def initialize({})\n      super({}_DISCRIMINANT, {})\n    end\n",
                        init_params.join(", "),
                        to_screaming_snake_case(name),
                        init_args.join(", ")
                    ));
                    output.push_str("  end\n\n");
                }
            }
        }

        output.push_str("end\n");
    }

    output
}

/// Convert PascalCase/camelCase to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4);
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

/// Convert to SCREAMING_SNAKE_CASE
fn to_screaming_snake_case(s: &str) -> String {
    to_snake_case(s).to_uppercase()
}

/// Map IR type to Ruby type (for documentation)
fn map_type_to_ruby(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            // All integer types map to Integer (Ruby has arbitrary precision)
            "u8" | "u16" | "u32" | "u64" | "u128" | "i8" | "i16" | "i32" | "i64" | "i128" => {
                "Integer".to_string()
            }

            // Floating point
            "f32" | "f64" => "Float".to_string(),

            // Boolean
            "bool" => "Boolean".to_string(),

            // String
            "String" => "String".to_string(),

            // Solana types
            "Pubkey" | "PublicKey" => "String".to_string(), // Base58 or hex string
            "Signature" => "String".to_string(),

            // Unknown - pass through
            _ => type_name.clone(),
        },
        TypeInfo::Array(inner) | TypeInfo::FixedArray { element: inner, .. } => {
            let inner_type = map_type_to_ruby(inner);
            format!("Array<{}>", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_ruby(inner);
            format!("{}, nil", inner_type)
        }
        TypeInfo::Generic(param_name) => param_name.clone(),
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

/// Map IR type to Borsh schema type (for borsh-rb)
fn map_type_to_borsh(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            "u8" => ":u8".to_string(),
            "u16" => ":u16".to_string(),
            "u32" => ":u32".to_string(),
            "u64" => ":u64".to_string(),
            "u128" => ":u128".to_string(),
            "i8" => ":i8".to_string(),
            "i16" => ":i16".to_string(),
            "i32" => ":i32".to_string(),
            "i64" => ":i64".to_string(),
            "i128" => ":i128".to_string(),
            "f32" => ":f32".to_string(),
            "f64" => ":f64".to_string(),
            "bool" => ":bool".to_string(),
            "String" => ":string".to_string(),
            "Pubkey" | "PublicKey" => "[:u8, 32]".to_string(), // 32-byte array
            "Signature" => "[:u8, 64]".to_string(),           // 64-byte array
            _ => format!("# Unknown: {}", type_name),
        },
        TypeInfo::Array(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("[:array, {}]", inner_borsh)
        }
        TypeInfo::FixedArray { element, size } => {
            let element_borsh = map_type_to_borsh(element);
            format!("[{}, {}]", element_borsh, size)
        }
        TypeInfo::Option(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("[:option, {}]", inner_borsh)
        }
        TypeInfo::Generic(param_name) => {
            format!("# Generic: {}", param_name)
        }
        TypeInfo::UserDefined(type_name) => {
            format!("{}::SCHEMA", type_name)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, StructDefinition, TypeDefinition, Visibility};

    #[test]
    fn generates_simple_class() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "User".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("class User"));
        assert!(code.contains("attr_accessor :id, :name"));
        assert!(code.contains("def initialize(opts = {})"));
        assert!(code.contains("@id = opts[:id]"));
        assert!(code.contains("@name = opts[:name]"));
    }

    #[test]
    fn generates_solana_class_with_borsh() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("class UserAccount"));
        assert!(code.contains("attr_accessor :wallet, :balance"));
        assert!(code.contains("SCHEMA = {"));
        assert!(code.contains("wallet => [:u8, 32]"));
        assert!(code.contains("balance => :u64"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Profile".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("# @option opts [String, nil] :email"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Team".to_string(),
            generic_params: vec![],
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
                deprecated: None,
                anchor_attrs: vec![],
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("# @option opts [Array<Integer>] :members"));
        assert!(code.contains("members => [:array, :u64]"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "User".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "Post".to_string(),
                generic_params: vec![],
                fields: vec![],
                metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("class User"));
        assert!(code.contains("class Post"));
        // Only one header
        assert_eq!(code.matches("# frozen_string_literal: true").count(), 1);
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Finished".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("module GameState"));
        assert!(code.contains("ACTIVE = 0"));
        assert!(code.contains("PAUSED = 1"));
        assert!(code.contains("FINISHED = 2"));
        assert!(code.contains("def self.name_for(value)"));
    }

    #[test]
    fn generates_complex_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameEvent".to_string(),
            generic_params: vec![],
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Started".to_string(),
                },
                EnumVariantDefinition::Tuple {
                    name: "PlayerJoined".to_string(),
                    types: vec![TypeInfo::Primitive("PublicKey".to_string())],
                },
                EnumVariantDefinition::Struct {
                    name: "ScoreUpdate".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "player".to_string(),
                            type_info: TypeInfo::Primitive("PublicKey".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                        FieldDefinition {
                            name: "score".to_string(),
                            type_info: TypeInfo::Primitive("u64".to_string()),
                            optional: false,
                            deprecated: None,
                            anchor_attrs: vec![],
                        },
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
                version: None,
                custom_derives: vec![],
                is_instruction: false,
                anchor_attrs: vec![],
            },
            visibility: Visibility::Public,
            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("module GameEvent"));
        assert!(code.contains("STARTED_DISCRIMINANT = 0"));
        assert!(code.contains("PLAYER_JOINED_DISCRIMINANT = 1"));
        assert!(code.contains("SCORE_UPDATE_DISCRIMINANT = 2"));
        assert!(code.contains("Started = Struct.new(:discriminant)"));
        assert!(code.contains("PlayerJoined = Struct.new(:discriminant, :field0)"));
        assert!(code.contains("ScoreUpdate = Struct.new(:discriminant, :player, :score)"));
    }

    #[test]
    fn maps_all_primitive_types() {
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("u8".to_string())),
            "Integer"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("u64".to_string())),
            "Integer"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("u128".to_string())),
            "Integer"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("i64".to_string())),
            "Integer"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("f64".to_string())),
            "Float"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("bool".to_string())),
            "Boolean"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("String".to_string())),
            "String"
        );
        assert_eq!(
            map_type_to_ruby(&TypeInfo::Primitive("PublicKey".to_string())),
            "String"
        );
    }

    #[test]
    fn handles_deprecated_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Account".to_string(),
            generic_params: vec![],
            fields: vec![
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                    deprecated: None,
                    anchor_attrs: vec![],
                },
                FieldDefinition {
                    name: "oldField".to_string(),
                    type_info: TypeInfo::Primitive("u32".to_string()),
                    optional: false,
                    deprecated: Some("Use new_field instead".to_string()),
                    anchor_attrs: vec![],
                },
            ],
            metadata: Metadata::default(),
            visibility: Visibility::Public,

            module_path: Vec::new(),
        });

        let code = generate(&type_def);
        assert!(code.contains("# Deprecated fields:"));
        assert!(code.contains("oldField: Use new_field instead"));
        assert!(code.contains("@deprecated Use new_field instead"));
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(to_snake_case("userId"), "user_id");
        assert_eq!(to_snake_case("simple"), "simple");
        assert_eq!(to_snake_case("ABCDef"), "a_b_c_def");
    }

    #[test]
    fn test_to_screaming_snake_case() {
        assert_eq!(to_screaming_snake_case("HelloWorld"), "HELLO_WORLD");
        assert_eq!(to_screaming_snake_case("Active"), "ACTIVE");
    }
}
